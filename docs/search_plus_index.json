{"./":{"url":"./","title":"简介","keywords":"","body":"大家好，这是我的个人笔记，使用Gitbook编写 俗话说好记性不如烂笔头, 就算脑子再好使，但它毕竟存储有限，还是要善于做笔记， 可以大幅提高我们的效率。 主要总结了计算机 金融投资 相关的笔记 愿你既能朝九晚五，又能浪迹天涯 愿你以梦为马，随处可栖 愿你有披着星辰的夜晚，也有说走就走的旅行 愿你付出甘之如怡，所得归之欢喜 愿你道路漫长，有的是时间发生故事 愿你永远年轻，永远热泪盈眶 愿你既能读万卷书，也能行万里路 愿你出走半生，归来仍是少年 var className='atoc';"},"Basic/Network/HTTP协议.html":{"url":"Basic/Network/HTTP协议.html","title":"HTTP协议","keywords":"","body":"HTTP 协议 HTTP 的特性 HTTP 协议构建于 TCP/IP 协议之上，是一个应用层协议，默认端口号是 80 HTTP 是无连接无状态的 HTTP 报文 请求报文 HTTP 协议是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范。规范把 HTTP 请求分为三个部分：状态行、请求头、消息主体。类似于下面这样： HTTP 定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而 HTTP 中的GET，POST，PUT，DELETE就对应着对这个资源的查，增，改，删4个操作。 GET 用于信息获取，而且应该是安全的 和 幂等的。 所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。 幂等的意味着对同一 URL 的多个请求应该返回同样的结果。 GET 请求报文示例： GET /books/?sex=man&name=Professional HTTP/1.1 Host: www.example.com User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6) Gecko/20050225 Firefox/1.0.1 Connection: Keep-Alive POST 表示可能修改变服务器上的资源的请求。 POST / HTTP/1.1 Host: www.example.com User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6) Gecko/20050225 Firefox/1.0.1 Content-Type: application/x-www-form-urlencoded Content-Length: 40 Connection: Keep-Alive sex=man&name=Professional 注意: GET 可提交的数据量受到URL长度的限制，HTTP 协议规范没有对 URL 长度进行限制。这个限制是特定的浏览器及服务器对它的限制 理论上讲，POST 是没有大小限制的，HTTP 协议规范也没有进行大小限制，出于安全考虑，服务器软件在实现时会做一定限制 参考上面的报文示例，可以发现 GET 和 POST 数据内容是一模一样的，只是位置不同，一个在 URL 里，一个在 HTTP 包的包体里 POST 提交数据的方式 HTTP 协议中规定 POST 提交的数据必须在 body 部分中，但是协议中没有规定数据使用哪种编码方式或者数据格式。实际上，开发者完全可以自己决定消息主体的格式，只要最后发送的 HTTP 请求满足上面的格式就可以。 但是，数据发送出去，还要服务端解析成功才有意义。一般服务端语言如 PHP、Python 等，以及它们的 framework，都内置了自动解析常见数据格式的功能。服务端通常是根据请求头（headers）中的 Content-Type 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。所以说到 POST 提交数据方案，包含了 Content-Type 和消息主体编码方式两部分。下面就正式开始介绍它们： application/x-www-form-urlencoded 这是最常见的 POST 数据提交方式。浏览器的原生 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。上个小节当中的例子便是使用了这种提交方式。可以看到 body 当中的内容和 GET 请求是完全相同的。 multipart/form-data 这又是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 表单的 enctype 等于 multipart/form-data。直接来看一个请求示例： POST http://www.example.com HTTP/1.1 Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA ------WebKitFormBoundaryrGKCBY7qhFd3TrwA Content-Disposition: form-data; name=\"text\" title ------WebKitFormBoundaryrGKCBY7qhFd3TrwA Content-Disposition: form-data; name=\"file\"; filename=\"chrome.png\" Content-Type: image/png PNG ... content of chrome.png ... ------WebKitFormBoundaryrGKCBY7qhFd3TrwA-- 这个例子稍微复杂点。首先生成了一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。然后 Content-Type 里指明了数据是以 multipart/form-data 来编码，本次请求的 boundary 是什么内容。消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 --boundary 开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 --boundary-- 标示结束。关于 multipart/form-data 的详细定义，请前往 RFC1867 查看（或者相对友好一点的 MDN 文档）。 这种方式一般用来上传文件，各大服务端语言对它也有着良好的支持。 上面提到的这两种 POST 数据的方式，都是浏览器原生支持的，而且现阶段标准中原生 表单也只支持这两种方式（通过 元素的 enctype 属性指定，默认为 application/x-www-form-urlencoded。其实 enctype 还支持 text/plain，不过用得非常少）。 随着越来越多的 Web 站点，尤其是 WebApp，全部使用 Ajax 进行数据交互之后，我们完全可以定义新的数据提交方式，例如 application/json，text/xml，乃至 application/x-protobuf 这种二进制格式，只要服务器可以根据 Content-Type 和 Content-Encoding 正确地解析出请求，都是没有问题的。 响应报文 HTTP 响应与 HTTP 请求相似，HTTP响应也由3个部分构成，分别是： 状态行 响应头(Response Header) 响应正文 状态行由协议版本、数字形式的状态代码、及相应的状态描述，各元素之间以空格分隔。 常见的状态码有如下几种： 200 OK 客户端请求成功 301 Moved Permanently 请求永久重定向 302 Moved Temporarily 请求临时重定向 304 Not Modified 文件未修改，可以直接使用缓存的文件。 400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。 401 Unauthorized 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因 404 Not Found 请求的资源不存在，例如，输入了错误的URL 500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。 503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。 下面是一个HTTP响应的例子： HTTP/1.1 200 OK Server:Apache Tomcat/5.0.12 Date:Mon,6Oct2003 13:23:42 GMT Content-Length:112 ... 条件 GET HTTP 条件 GET 是 HTTP 协议为了减少不必要的带宽浪费，提出的一种方案。详见 RFC2616 。 HTTP 条件 GET 使用的时机？ 客户端之前已经访问过某网站，并打算再次访问该网站。 HTTP 条件 GET 使用的方法？ 客户端向服务器发送一个包询问是否在上一次访问网站的时间后是否更改了页面，如果服务器没有更新，显然不需要把整个网页传给客户端，客户端只要使用本地缓存即可，如果服务器对照客户端给出的时间已经更新了客户端请求的网页，则发送这个更新了的网页给用户。 下面是一个具体的发送接受报文示例： 客户端发送请求： GET / HTTP/1.1 Host: www.sina.com.cn:80 If-Modified-Since:Thu, 4 Feb 2010 20:39:13 GMT Connection: Close 第一次请求时，服务器端返回请求数据，之后的请求，服务器根据请求中的 If-Modified-Since 字段判断响应文件没有更新，如果没有更新，服务器返回一个 304 Not Modified响应，告诉浏览器请求的资源在浏览器上没有更新，可以使用已缓存的上次获取的文件。 HTTP/1.0 304 Not Modified Date: Thu, 04 Feb 2010 12:38:41 GMT Content-Type: text/html Expires: Thu, 04 Feb 2010 12:39:41 GMT Last-Modified: Thu, 04 Feb 2010 12:29:04 GMT Age: 28 X-Cache: HIT from sy32-21.sina.com.cn Connection: close 如果服务器端资源已经更新的话，就返回正常的响应。 持久连接 我们知道 HTTP 协议采用“请求-应答”模式，当使用普通模式，即非 Keep-Alive 模式时，每个请求/应答客户和服务器都要新建一个连接，完成之后立即断开连接（HTTP 协议为无连接的协议）；当使用 Keep-Alive 模式（又称持久连接、连接重用）时，Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接。 在 HTTP 1.0 版本中，并没有官方的标准来规定 Keep-Alive 如何工作，因此实际上它是被附加到 HTTP 1.0协议上，如果客户端浏览器支持 Keep-Alive ，那么就在HTTP请求头中添加一个字段 Connection: Keep-Alive，当服务器收到附带有 Connection: Keep-Alive 的请求时，它也会在响应头中添加一个同样的字段来使用 Keep-Alive 。这样一来，客户端和服务器之间的HTTP连接就会被保持，不会断开（超过 Keep-Alive 规定的时间，意外断电等情况除外），当客户端发送另外一个请求时，就使用这条已经建立的连接。 在 HTTP 1.1 版本中，默认情况下所有连接都被保持，如果加入 \"Connection: close\" 才关闭。目前大部分浏览器都使用 HTTP 1.1 协议，也就是说默认都会发起 Keep-Alive 的连接请求了，所以是否能完成一个完整的 Keep-Alive 连接就看服务器设置情况。 由于 HTTP 1.0 没有官方的 Keep-Alive 规范，并且也已经基本被淘汰，以下讨论均是针对 HTTP 1.1 标准中的 Keep-Alive 展开的。 注意： HTTP Keep-Alive 简单说就是保持当前的TCP连接，避免了重新建立连接。 HTTP 长连接不可能一直保持，例如 Keep-Alive: timeout=5, max=100，表示这个TCP通道可以保持5秒，max=100，表示这个长连接最多接收100次请求就断开。 HTTP 是一个无状态协议，这意味着每个请求都是独立的，Keep-Alive 没能改变这个结果。另外，Keep-Alive也不能保证客户端和服务器之间的连接一定是活跃的，在 HTTP1.1 版本中也如此。唯一能保证的就是当连接被关闭时你能得到一个通知，所以不应该让程序依赖于 Keep-Alive 的保持连接特性，否则会有意想不到的后果。 使用长连接之后，客户端、服务端怎么知道本次传输结束呢？两部分：1. 判断传输数据是否达到了Content-Length 指示的大小；2. 动态生成的文件没有 Content-Length ，它是分块传输（chunked），这时候就要根据 chunked 编码来判断，chunked 编码的数据在最后有一个空 chunked 块，表明本次传输数据结束，详见这里。什么是 chunked 分块传输呢？下面我们就来介绍一下。 Transfer-Encoding Transfer-Encoding 是一个用来标示 HTTP 报文传输格式的头部值。尽管这个取值理论上可以有很多，但是当前的 HTTP 规范里实际上只定义了一种传输取值——chunked。 如果一个HTTP消息（请求消息或应答消息）的Transfer-Encoding消息头的值为chunked，那么，消息体由数量未定的块组成，并以最后一个大小为0的块为结束。 每一个非空的块都以该块包含数据的字节数（字节数以十六进制表示）开始，跟随一个CRLF （回车及换行），然后是数据本身，最后块CRLF结束。在一些实现中，块大小和CRLF之间填充有白空格（0x20）。 最后一块是单行，由块大小（0），一些可选的填充白空格，以及CRLF。最后一块不再包含任何数据，但是可以发送可选的尾部，包括消息头字段。消息最后以CRLF结尾。 一个示例响应如下： HTTP/1.1 200 OK Content-Type: text/plain Transfer-Encoding: chunked 25 This is the data in the first chunk 1A and this is the second one 0 注意： chunked 和 multipart 两个名词在意义上有类似的地方，不过在 HTTP 协议当中这两个概念则不是一个类别的。multipart 是一种 Content-Type，标示 HTTP 报文内容的类型，而 chunked 是一种传输格式，标示报头将以何种方式进行传输。 chunked 传输不能事先知道内容的长度，只能靠最后的空 chunk 块来判断，因此对于下载请求来说，是没有办法实现进度的。在浏览器和下载工具中，偶尔我们也会看到有些文件是看不到下载进度的，即采用 chunked 方式进行下载。 chunked 的优势在于，服务器端可以边生成内容边发送，无需事先生成全部的内容。HTTP/2 不支持 Transfer-Encoding: chunked，因为 HTTP/2 有自己的 streaming 传输方式（Source：MDN - Transfer-Encoding）。 HTTP Pipelining（HTTP 管线化） 默认情况下 HTTP 协议中每个传输层连接只能承载一个 HTTP 请求和响应，浏览器会在收到上一个请求的响应之后，再发送下一个请求。在使用持久连接的情况下，某个连接上消息的传递类似于请求1 -> 响应1 -> 请求2 -> 响应2 -> 请求3 -> 响应3。 HTTP Pipelining（管线化）是将多个 HTTP 请求整批提交的技术，在传送过程中不需等待服务端的回应。使用 HTTP Pipelining 技术之后，某个连接上的消息变成了类似这样请求1 -> 请求2 -> 请求3 -> 响应1 -> 响应2 -> 响应3。 注意下面几点： 管线化机制通过持久连接（persistent connection）完成，仅 HTTP/1.1 支持此技术（HTTP/1.0不支持） 只有 GET 和 HEAD 请求可以进行管线化，而 POST 则有所限制 初次创建连接时不应启动管线机制，因为对方（服务器）不一定支持 HTTP/1.1 版本的协议 管线化不会影响响应到来的顺序，如上面的例子所示，响应返回的顺序并未改变 HTTP /1.1 要求服务器端支持管线化，但并不要求服务器端也对响应进行管线化处理，只是要求对于管线化的请求不失败即可 由于上面提到的服务器端问题，开启管线化很可能并不会带来大幅度的性能提升，而且很多服务器端和代理程序对管线化的支持并不好，因此现代浏览器如 Chrome 和 Firefox 默认并未开启管线化支持 更多关于 HTTP Pipelining 的知识可以参考这里。 会话跟踪 什么是会话？ 客户端打开与服务器的连接发出请求到服务器响应客户端请求的全过程称之为会话。 什么是会话跟踪？ 会话跟踪指的是对同一个用户对服务器的连续的请求和接受响应的监视。 为什么需要会话跟踪？ 浏览器与服务器之间的通信是通过HTTP协议进行通信的，而HTTP协议是”无状态”的协议，它不能保存客户的信息，即一次响应完成之后连接就断开了，下一次的请求需要重新连接，这样就需要判断是否是同一个用户，所以才有会话跟踪技术来实现这种要求。 会话跟踪常用的方法: URL 重写 URL(统一资源定位符)是Web上特定页面的地址，URL重写的技术就是在URL结尾添加一个附加数据以标识该会话,把会话ID通过URL的信息传递过去，以便在服务器端进行识别不同的用户。 隐藏表单域 将会话ID添加到HTML表单元素中提交到服务器，此表单元素并不在客户端显示 Cookie Cookie 是Web 服务器发送给客户端的一小段信息，客户端请求时可以读取该信息发送到服务器端，进而进行用户的识别。对于客户端的每次请求，服务器都会将 Cookie 发送到客户端,在客户端可以进行保存,以便下次使用。 客户端可以采用两种方式来保存这个 Cookie 对象，一种方式是保存在客户端内存中，称为临时 Cookie，浏览器关闭后这个 Cookie 对象将消失。另外一种方式是保存在客户机的磁盘上，称为永久 Cookie。以后客户端只要访问该网站，就会将这个 Cookie 再次发送到服务器上，前提是这个 Cookie 在有效期内，这样就实现了对客户的跟踪。 Cookie 是可以被客户端禁用的。 Session: 每一个用户都有一个不同的 session，各个用户之间是不能共享的，是每个用户所独享的，在 session 中可以存放信息。 在服务器端会创建一个 session 对象，产生一个 sessionID 来标识这个 session 对象，然后将这个 sessionID 放入到 Cookie 中发送到客户端，下一次访问时，sessionID 会发送到服务器，在服务器端进行识别不同的用户。 Session 的实现依赖于 Cookie，如果 Cookie 被禁用，那么 session 也将失效。 跨站攻击 CSRF（Cross-site request forgery，跨站请求伪造） CSRF(XSRF) 顾名思义，是伪造请求，冒充用户在站内的正常操作。 例如，一论坛网站的发贴是通过 GET 请求访问，点击发贴之后 JS 把发贴内容拼接成目标 URL 并访问： http://example.com/bbs/create_post.php?title=标题&content=内容 那么，我们只需要在论坛中发一帖，包含一链接： http://example.com/bbs/create_post.php?title=我是脑残&content=哈哈 只要有用户点击了这个链接，那么他们的帐户就会在不知情的情况下发布了这一帖子。可能这只是个恶作剧，但是既然发贴的请求可以伪造，那么删帖、转帐、改密码、发邮件全都可以伪造。 如何防范 CSRF 攻击？可以注意以下几点： 关键操作只接受 POST 请求 验证码 CSRF 攻击的过程，往往是在用户不知情的情况下构造网络请求。所以如果使用验证码，那么每次操作都需要用户进行互动，从而简单有效的防御了CSRF攻击。 但是如果你在一个网站作出任何举动都要输入验证码会严重影响用户体验，所以验证码一般只出现在特殊操作里面，或者在注册时候使用。 检测 Referer 常见的互联网页面与页面之间是存在联系的，比如你在 www.baidu.com 应该是找不到通往www.google.com 的链接的，再比如你在论坛留言，那么不管你留言后重定向到哪里去了，之前的那个网址一定会包含留言的输入框，这个之前的网址就会保留在新页面头文件的 Referer 中 通过检查 Referer 的值，我们就可以判断这个请求是合法的还是非法的，但是问题出在服务器不是任何时候都能接受到 Referer 的值，所以 Referer Check 一般用于监控 CSRF 攻击的发生，而不用来抵御攻击。 Token 目前主流的做法是使用 Token 抵御 CSRF 攻击。下面通过分析 CSRF 攻击来理解为什么 Token 能够有效 CSRF 攻击要成功的条件在于攻击者能够预测所有的参数从而构造出合法的请求。所以根据不可预测性原则，我们可以对参数进行加密从而防止 CSRF 攻击。 另一个更通用的做法是保持原有参数不变，另外添加一个参数 Token，其值是随机的。这样攻击者因为不知道 Token 而无法构造出合法的请求进行攻击。 Token 使用原则 Token 要足够随机————只有这样才算不可预测 Token 是一次性的，即每次请求成功后要更新Token————这样可以增加攻击难度，增加预测难度 Token 要注意保密性————敏感操作使用 post，防止 Token 出现在 URL 中 注意：过滤用户输入的内容不能阻挡 csrf，我们需要做的是过滤请求的来源。 XSS（Cross Site Scripting，跨站脚本攻击） XSS 全称“跨站脚本”，是注入攻击的一种。其特点是不对服务器端造成任何伤害，而是通过一些正常的站内交互途径，例如发布评论，提交含有 JavaScript 的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本。 运行预期之外的脚本带来的后果有很多中，可能只是简单的恶作剧——一个关不掉的窗口： while (true) { alert(\"你关不掉我~\"); } 也可以是盗号或者其他未授权的操作。 XSS 是实现 CSRF 的诸多途径中的一条，但绝对不是唯一的一条。一般习惯上把通过 XSS 来实现的 CSRF 称为 XSRF。 如何防御 XSS 攻击？ 理论上，所有可输入的地方没有对输入数据进行处理的话，都会存在 XSS 漏洞，漏洞的危害取决于攻击代码的威力，攻击代码也不局限于 script。防御 XSS 攻击最简单直接的方法，就是过滤用户的输入。 如果不需要用户输入 HTML，可以直接对用户的输入进行 HTML escape 。下面一小段脚本： window.location.href=”http://www.baidu.com”; 经过 escape 之后就成了： &lt;script&gt;window.location.href=&quot;http://www.baidu.com&quot;&lt;/script&gt; 它现在会像普通文本一样显示出来，变得无毒无害，不能执行了。 当我们需要用户输入 HTML 的时候，需要对用户输入的内容做更加小心细致的处理。仅仅粗暴地去掉 script 标签是没有用的，任何一个合法 HTML 标签都可以添加 onclick 一类的事件属性来执行 JavaScript。更好的方法可能是，将用户的输入使用 HTML 解析库进行解析，获取其中的数据。然后根据用户原有的标签属性，重新构建 HTML 元素树。构建的过程中，所有的标签、属性都只从白名单中拿取。 var className='atoc';"},"Basic/Network/HTTPS协议.html":{"url":"Basic/Network/HTTPS协议.html","title":"HTTPS协议","keywords":"","body":"HTTPS协议 HTTPS 基本过程 HTTPS 即 HTTP over TLS，是一种在加密信道进行 HTTP 内容传输的协议。 TLS 的早期版本叫做 SSL。SSL 的 1.0, 2.0, 3.0 版本均已经被废弃，出于安全问题考虑广大浏览器也不再对老旧的 SSL 版本进行支持了，因此这里我们就统一使用 TLS 名称了。 TLS 的基本过程如下（取自 what-happens-when-zh_CN）： 客户端发送一个 ClientHello 消息到服务器端，消息中同时包含了它的 Transport Layer Security (TLS) 版本，可用的加密算法和压缩算法。 服务器端向客户端返回一个 ServerHello 消息，消息中包含了服务器端的 TLS 版本，服务器所选择的加密和压缩算法，以及数字证书认证机构（Certificate Authority，缩写 CA）签发的服务器公开证书，证书中包含了公钥。客户端会使用这个公钥加密接下来的握手过程，直到协商生成一个新的对称密钥。证书中还包含了该证书所应用的域名范围（Common Name，简称 CN），用于客户端验证身份。 客户端根据自己的信任 CA 列表，验证服务器端的证书是否可信。如果认为可信（具体的验证过程在下一节讲解），客户端会生成一串伪随机数，使用服务器的公钥加密它。这串随机数会被用于生成新的对称密钥 服务器端使用自己的私钥解密上面提到的随机数，然后使用这串随机数生成自己的对称主密钥 客户端发送一个 Finished 消息给服务器端，使用对称密钥加密这次通讯的一个散列值 服务器端生成自己的 hash 值，然后解密客户端发送来的信息，检查这两个值是否对应。如果对应，就向客户端发送一个 Finished 消息，也使用协商好的对称密钥加密 从现在开始，接下来整个 TLS 会话都使用对称秘钥进行加密，传输应用层（HTTP）内容 从上面的过程可以看到，TLS 的完整过程需要三个算法（协议），密钥交互算法，对称加密算法，和消息认证算法（TLS 的传输会使用 MAC(message authentication code) 进行完整性检查）。 我们以 Github 网站使用的 TLS 为例，使用浏览器可以看到它使用的加密为 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256。其中密钥交互算法是 ECDHE_RSA，对称加密算法是 AES_128_GCM，消息认证（MAC）算法为 SHA256。 TLS 证书机制 HTTPS 过程中很重要的一个步骤，是服务器需要有 CA 颁发的证书，客户端根据自己的信任 CA 列表验证服务器的身份。现代浏览器中，证书验证的过程依赖于证书信任链。 所谓证书信任链，即一个证书要依靠上一级证书来证明自己是可信的，最顶层的证书被称为根证书，拥有根证书的机构被称为根 CA。 还是以 Github 为例，在浏览器中我们可以看到它的证书信任链如下： DigiCert High Assurance EV Root CA -> DigiCert SHA2 Extended Validation Server CA -> Github.com 从上到下即 Root CA -> 二级 CA -> 网站。 前面提到，证书当中包括 CN(Common Name)，浏览器在验证证书的同时，也会验证 CN 的正确性。即不光需要验证“这是一个合法的证书”，还需要验证“这是一个用于 Github.com 的证书”。 既然所有的信任，最终要落到根 CA 上，根证书本身又是怎么获得的呢？答案也很简单，根证书一般是操作系统自带的。不管是桌面系统 Windows，macOS 还是移动端系统 Android, iOS 都会内置一系列根证书。随着操作系统本身的升级，根证书也会随着升级进行更新。 对浏览器而已，浏览器当然也有选择信任某个根证书的权利。Chrome 浏览器一般是跟随系统根证书信任的。Firefox 浏览器通常是使用自带的一套证书信任机制，不受系统证书的影响。 在使用 curl 等工具时，我们还可以自行选择证书进行信任。 有权威的信任，最终都要落到一个单点信任，不管是 Root CA，还是微软，苹果，谷歌等操作系统厂商。 中间人攻击 HTTPS 的过程并不是密不透风的，HTTPS 有若干漏洞，给中间人攻击（Man In The Middle Attack，简称 MITM）提供了可能。 所谓中间人攻击，指攻击者与通讯的两端分别建立独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。 SSL 剥离 SSL 剥离即阻止用户使用 HTTPS 访问网站。由于并不是所有网站都只支持 HTTPS，大部分网站会同时支持 HTTP 和 HTTPS 两种协议。用户在访问网站时，也可能会在地址栏中输入 http:// 的地址，第一次的访问完全是明文的，这就给了攻击者可乘之机。通过攻击 DNS 响应，攻击者可以将自己变成中间人。 DNS 作为基于 UDP 的协议是相当不安全的，为了保证 DNS 的安全可以使用 DNS over TCP 等机制，这里不赘述了。 HSTS 为了防止上面说的这种情况，一种叫做 HSTS 的技术被引入了。HSTS（HTTP Strict Transport Security）是用于强制浏览器使用 HTTPS 访问网站的一种机制。它的基本机制是在服务器返回的响应中，加上一个特殊的头部，指示浏览器对于此网站，强制使用 HTTPS 进行访问： Strict-Transport-Security: max-age=31536000; includeSubdomains; preload 可以看到如果这个过期时间非常长，就是导致在很长一段时间内，浏览器都会强制使用 HTTPS 访问该网站。 HSTS 有一个很明显的缺点，是需要等待第一个服务器的影响中的头部才能生效，但如果第一次访问该网站就被攻击呢？为了解决这个问题，浏览器中会带上一些网站的域名，被称为 HSTS preload list。对于在这个 list 的网站来说，直接强制使用 HTTPS。 伪造证书攻击 HSTS 只解决了 SSL 剥离的问题，然而即使在全程使用 HTTPS 的情况下，我们仍然有可能被监听。 假设我们想访问 www.google.com，但我们的 DNS 服务器被攻击了，指向的 IP 地址并非 Google 的服务器，而是攻击者的 IP。当攻击者的服务器也有合法的证书的时候，我们的浏览器就会认为对方是 Google 服务器，从而信任对方。这样，攻击者便可以监听我们和谷歌之前的所有通信了。 可以看到攻击者有两步需要操作，第一步是需要攻击 DNS 服务器。第二步是攻击者自己的证书需要被用户信任，这一步对于用户来说是很难控制的，需要证书颁发机构能够控制自己不滥发证书。 2015 年 Google 称发现赛门铁克旗下的 Thawte 未经同意签发了众多域名的数千个证书，其中包括 Google 旗下的域名和不存在的域名。当年 12 月，Google 发布公告称 Chrome、Android 及其他 Google 产品将不再信任赛门铁克旗下的\"Class 3 Public Primary CA\"根证书。 2016 年 Mozilla 发现沃通 CA 存在严重的信任问题，例如偷签 github.com 的证书，故意倒填证书日期绕过浏览器对 SHA-1 证书的限制等，将停止信任 WoSign 和 StartCom 签发的新证书。 HPKP HPKP 技术是为了解决伪造证书攻击而诞生的。 HPKP（Public Key Pinning Extension for HTTP）在 HSTS 上更进一步，HPKP 直接在返回头中存储服务器的公钥指纹信息，一旦发现指纹和实际接受到的公钥有差异，浏览器就可以认为正在被攻击： Public-Key-Pins: pin-sha256=\"base64==\"; max-age=expireTime [; includeSubDomains][; report-uri=\"reportURI\"] 和 HSTS 类似，HPKP 也依赖于服务器的头部返回，不能解决第一次访问的问题，浏览器本身也会内置一些 HPKP 列表。 HPKP 技术仍然不能阻止第一次访问的攻击问题，部署和配置 HPKP 相当繁琐，一旦网站配置错误，就会导致网站证书验证失败，且在过期时间内无法有效恢复。HPKP 的机制也引来了一些安全性问题。Chrome 67 中废除了对 HPKP 的支持，在 Chrome 72 中 HPKP 被彻底移除。 var className='atoc';"},"Basic/Network/TCP协议.html":{"url":"Basic/Network/TCP协议.html","title":"TCP协议","keywords":"","body":"TCP协议 TCP 的特性 TCP 提供一种面向连接的、可靠的字节流服务 在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP TCP 使用校验和，确认和重传机制来保证可靠传输 TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复 TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制 注意：TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。 三次握手与四次挥手 所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。 三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 connect() 时。将触发三次握手。 第一次握手(SYN=1, seq=x): 客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。 发送完毕后，客户端进入 SYN_SEND 状态。 第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1): 服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 SYN_RCVD 状态。 第三次握手(ACK=1，ACKnum=y+1) 客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1 发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。 三次握手的过程的示意图如下： TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。 第一次挥手(FIN=1，seq=x) 假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。 发送完毕后，客户端进入 FIN_WAIT_1 状态。 第二次挥手(ACK=1，ACKnum=x+1) 服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。 发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。 第三次挥手(FIN=1，seq=y) 服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。 发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。 第四次挥手(ACK=1，ACKnum=y+1) 客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。 服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。 客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。 四次挥手的示意图如下： SYN攻击 什么是 SYN 攻击（SYN Flood）？ 在三次握手过程中，服务器发送 SYN-ACK 之后，收到客户端的 ACK 之前的 TCP 连接称为半连接(half-open connect)。此时服务器处于 SYN_RCVD 状态。当收到 ACK 后，服务器才能转入 ESTABLISHED 状态. SYN 攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。 SYN 攻击是一种典型的 DoS/DDoS 攻击。 如何检测 SYN 攻击？ 检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。 如何防御 SYN 攻击？ SYN攻击不能完全被阻止，除非将TCP协议重新设计。我们所做的是尽可能的减轻SYN攻击的危害，常见的防御 SYN 攻击的方法有如下几种： 缩短超时（SYN Timeout）时间 增加最大半连接数 过滤网关防护 SYN cookies技术 TCP KeepAlive TCP 的连接，实际上是一种纯软件层面的概念，在物理层面并没有“连接”这种概念。TCP 通信双方建立交互的连接，但是并不是一直存在数据交互，有些连接会在数据交互完毕后，主动释放连接，而有些不会。在长时间无数据交互的时间段内，交互双方都有可能出现掉电、死机、异常重启等各种意外，当这些意外发生之后，这些 TCP 连接并未来得及正常释放，在软件层面上，连接的另一方并不知道对端的情况，它会一直维护这个连接，长时间的积累会导致非常多的半打开连接，造成端系统资源的消耗和浪费，为了解决这个问题，在传输层可以利用 TCP 的 KeepAlive 机制实现来实现。主流的操作系统基本都在内核里支持了这个特性。 TCP KeepAlive 的基本原理是，隔一段时间给连接对端发送一个探测包，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。 TCP-Keepalive-HOWTO 有对 TCP KeepAlive 特性的详细介绍，有兴趣的同学可以参考。这里主要说一下，TCP KeepAlive 的局限。首先 TCP KeepAlive 监测的方式是发送一个 probe 包，会给网络带来额外的流量，另外 TCP KeepAlive 只能在内核层级监测连接的存活与否，而连接的存活不一定代表服务的可用。例如当一个服务器 CPU 进程服务器占用达到 100%，已经卡死不能响应请求了，此时 TCP KeepAlive 依然会认为连接是存活的。因此 TCP KeepAlive 对于应用层程序的价值是相对较小的。需要做连接保活的应用层程序，例如 QQ，往往会在应用层实现自己的心跳功能。 var className='atoc';"},"Basic/Network/UDP协议.html":{"url":"Basic/Network/UDP协议.html","title":"UDP协议","keywords":"","body":"UDP协议 UDP 简介 UDP 是一个简单的传输层协议。和 TCP 相比，UDP 有下面几个显著特性： UDP 缺乏可靠性。UDP 本身不提供确认，序列号，超时重传等机制。UDP 数据报可能在网络中被复制，被重新排序。即 UDP 不保证数据报会到达其最终目的地，也不保证各个数据报的先后顺序，也不保证每个数据报只到达一次 UDP 数据报是有长度的。每个 UDP 数据报都有长度，如果一个数据报正确地到达目的地，那么该数据报的长度将随数据一起传递给接收方。而 TCP 是一个字节流协议，没有任何（协议上的）记录边界。 UDP 是无连接的。UDP 客户和服务器之前不必存在长期的关系 UDP 发送数据报之前也不需要经过握手创建连接的过程。 UDP 支持多播和广播。 var className='atoc';"},"Basic/Network/Socket.html":{"url":"Basic/Network/Socket.html","title":"Socket","keywords":"","body":"Socket Socket 基本概念 Socket 是对 TCP/IP 协议族的一种封装，是应用层与TCP/IP协议族通信的中间软件抽象层。从设计模式的角度看来，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。 Socket 还可以认为是一种网络间不同计算机上的进程通信的一种方法，利用三元组（ip地址，协议，端口）就可以唯一标识网络中的进程，网络中的进程通信可以利用这个标志与其它进程进行交互。 Socket 起源于 Unix ，Unix/Linux 基本哲学之一就是“一切皆文件”，都可以用“打开(open) –> 读写(write/read) –> 关闭(close)”模式来进行操作。因此 Socket 也被处理为一种特殊的文件。 写一个简易的 WebServer 一个简易的 Server 的流程如下： 1.建立连接，接受一个客户端连接。 2.接受请求，从网络中读取一条 HTTP 请求报文。 3.处理请求，访问资源。 4.构建响应，创建带有 header 的 HTTP 响应报文。 5.发送响应，传给客户端。 省略流程 3，大体的程序与调用的函数逻辑如下： socket() 创建套接字 bind() 分配套接字地址 listen() 等待连接请求 accept() 允许连接请求 read()/write() 数据交换 close() 关闭连接 代码如下： #include #include #include #include #include #include #include #include #include using namespace std; const int port = 9090; const int buffer_size = 1Bad Request400 Bad Request\"; write(client_sock, status, sizeof(status)); write(client_sock, header, sizeof(header)); write(client_sock, body, sizeof(body)); } var className='atoc';"},"Basic/Network/WebSocket.html":{"url":"Basic/Network/WebSocket.html","title":"WebSocket","keywords":"","body":"WebSocket 什么是WebSocket WebSocket 是一种在单个TCP连接上进行全双工通信的协议。 WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。 在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输。（维基百科） WebSocket本质上一种计算机网络应用层的协议，用来弥补http协议在持久通信能力上的不足。 WebSocket 协议在2008年诞生，2011年成为国际标准。现在最新版本浏览器都已经支持了。 它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。 WebSocket 的其他特点包括： 建立在 TCP 协议之上，服务器端的实现比较容易。 与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。 数据格式比较轻量，性能开销小，通信高效。 可以发送文本，也可以发送二进制数据。 没有同源限制，客户端可以与任意服务器通信。 协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。 var className='atoc';"},"Basic/DataStruct/LinkList.html":{"url":"Basic/DataStruct/LinkList.html","title":"链表","keywords":"","body":"链表 例题 算法需要多刷题 LeetCode 单链表翻转 LeetCode 206 这个问题可以使用递归和非递归两种方法解决。 递归算法实现： ListNode* reverseList(ListNode* head) { if(NULL == head || NULL == head->next) return head; ListNode * p = reverseList(head->next); head->next->next = head; head->next = NULL; return p; } 非递归算法实现： ListNode* reverseList(ListNode* head) { ListNode *curr = head; if (curr == NULL) { return NULL; } ListNode *prev = NULL, *temp = NULL; while (curr != NULL) { temp = curr->next; curr->next = prev; prev = curr; curr = temp; } return prev; } 单链表判断是否有环 LeetCode 141 最容易想到的思路是存一个所有 Node 地址的 Hash 表，从头开始遍历，将 Node 存到 Hash 表中，如果出现了重复，则说明链表有环。 一个经典的方法是双指针（也叫快慢指针），使用两个指针遍历链表，一个指针一次走一步，另一个一次走两步，如果链表有环，两个指针必然相遇。 双指针算法实现： bool hasCycle(ListNode *head) { if (head == nullptr) { return false; } ListNode *fast,*slow; slow = head; fast = head->next; while (fast && fast->next) { slow = slow->next; fast = fast->next->next; if (slow == fast) { return true; } } return false; } 单链表找环入口 LeetCode 141 作为上一题的扩展，为了找到环所在的位置，在快慢指针相遇的时候，此时慢指针没有遍历完链表，再设置一个指针从链表头部开始遍历，这两个指针相遇的点，就是链表环的入口。 算法实现： ListNode *detectCycle(ListNode *head) { if (head == nullptr) { return nullptr; } ListNode *fast,*slow; slow = head; fast = head; while (fast && fast->next) { slow = slow->next; fast = fast->next->next; if (slow == fast) { ListNode *slow2 = head; while (slow2 != slow) { slow = slow->next; slow2 = slow2->next; } return slow2; } } return nullptr; } 单链表找交点 LeetCode 160 和找环的方法类似，同样可以使用 Hash 表存储所有节点，发现重复的节点即交点。 一个容易想到的方法是，先得到两个链表的长度，然后得到长度的差值 distance，两个指针分别从两个链表头部遍历，其中较长链表指针先走 distance 步，然后同时向后走，当两个指针相遇的时候，即链表的交点： int getListLength(ListNode *head) { if (head == nullptr) { return 0; } int length = 0; ListNode *p = head; while (p!=nullptr) { p = p->next; length ++; } return length; } ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { int lengthA = getListLength(headA); int lengthB = getListLength(headB); if (lengthA > lengthB) { std::swap(headA, headB); }; int distance = abs(lengthB - lengthA); ListNode *p1 = headA; ListNode *p2 = headB; while(distance--) { p2 = p2->next; } while (p1 != nullptr && p2 != nullptr) { if (p1 == p2) return p1; p1 = p1->next; p2 = p2->next; } return NULL; } 另一个较快的方法时，两个指针 pa，pb 分别从 headA，headB开始遍历，当 pa 遍历到尾部的时候，指向 headB，当 pb 遍历到尾部的时候，转向 headA。当两个指针再次相遇的时候，如果两个链表有交点，则指向交点，如果没有则指向 NULL： ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode *pa = headA; ListNode *pb = headB; while (pa != pb) { pa = pa != nullptr ? pa->next : headB; pb = pb != nullptr ? pb->next : headA; } return pa; } 单链表找中间节点 LeetCode 876 用快慢指针法，当快指针走到链表结尾时，慢指针刚好走到链表的中间： ListNode* middleNode(ListNode* head) { ListNode *slow = head; ListNode *fast = head; while (fast && fast->next) { slow = slow->next; fast = fast->next->next; } return slow; } 单链表合并 LeetCode 21 两个链表本身都是排序过的，把两个链表从头节点开始，逐个节点开始进行比较，最后剩下的节点接到尾部： ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) { if (l1 == nullptr) { return l2; } if (l2 == nullptr) { return l1; } ListNode dummy(-1); ListNode *p = &dummy; for (; l1 && l2; p = p->next) { if (l1->val val) { p->next = l1; l1 = l1->next; } else { p->next = l2; l2 = l2->next; } } p->next = l1 != nullptr ? l1 : l2; return dummy.next; } var className='atoc';"},"Basic/DataStruct/Tree.html":{"url":"Basic/DataStruct/Tree.html","title":"树","keywords":"","body":"树 基本知识 二叉树 二叉树：二叉树是有限个结点的集合，这个集合或者是空集，或者是由一个根结点和两株互不相交的二叉树组成，其中一株叫根的做左子树，另一棵叫做根的右子树。 二叉树的性质： 性质1：在二叉树中第 i 层的结点数最多为2^(i-1)（i ≥ 1） 性质2：高度为k的二叉树其结点总数最多为2^k－1（ k ≥ 1） 性质3：对任意的非空二叉树 T ，如果叶结点的个数为 n0，而其度为 2 的结点数为 n2，则：n0 = n2 + 1 满二叉树：深度为k且有2^k －1个结点的二叉树称为满二叉树 完全二叉树：深度为 k 的，有n个结点的二叉树，当且仅当其每个结点都与深度为 k 的满二叉树中编号从 1 至 n 的结点一一对应，称之为完全二叉树。（除最后一层外，每一层上的节点数均达到最大值；在最后一层上只缺少右边的若干结点） 性质4：具有 n 个结点的完全二叉树的深度为 log2n + 1 注意： 仅有前序和后序遍历，不能确定一个二叉树，必须有中序遍历的结果 堆 如果一棵完全二叉树的任意一个非终端结点的元素都不小于其左儿子结点和右儿子结点（如果有的话） 的元素，则称此完全二叉树为最大堆。 同样，如果一棵完全二叉树的任意一个非终端结点的元素都不大于其左儿子结点和右儿子结点（如果 有的话）的元素，则称此完全二叉树为最小堆。 最大堆的根结点中的元素在整个堆中是最大的； 最小堆的根结点中的元素在整个堆中是最小的。 哈弗曼树 定义：给定n个权值作为n的叶子结点，构造一棵二叉树，若带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman tree)。 构造： 假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，则哈夫曼树的构造规则为： 将w1、w2、…，wn看成是有 n 棵树的森林(每棵树仅有一个结点)； 在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和； 从森林中删除选取的两棵树，并将新树加入森林； 重复(2)、(3)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。 二叉排序树 二叉排序树（Binary Sort Tree）又称二叉查找树（Binary Search Tree），亦称二叉搜索树。 二叉排序树或者是一棵空树，或者是具有下列性质的二叉树： 若左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值； 左、右子树也分别为二叉排序树； 没有键值相等的节点 二分查找的时间复杂度是O(log(n))，最坏情况下的时间复杂度是O(n)（相当于顺序查找） 平衡二叉树 平衡二叉树（balanced binary tree）,又称 AVL 树。它或者是一棵空树,或者是具有如下性质的二叉树： 它的左子树和右子树都是平衡二叉树， 左子树和右子树的深度之差的绝对值不超过1。 平衡二叉树是对二叉搜索树(又称为二叉排序树)的一种改进。二叉搜索树有一个缺点就是，树的结构是无法预料的，随意性很大，它只与节点的值和插入的顺序有关系，往往得到的是一个不平衡的二叉树。在最坏的情况下，可能得到的是一个单支二叉树，其高度和节点数相同，相当于一个单链表，对其正常的时间复杂度有O(log(n))变成了O(n)，从而丧失了二叉排序树的一些应该有的优点。 B-树 B-树：B-树是一种非二叉的查找树， 除了要满足查找树的特性，还要满足以下结构特性： 一棵 m 阶的B-树： 树的根或者是一片叶子(一个节点的树),或者其儿子数在 2 和 m 之间。 除根外，所有的非叶子结点的孩子数在 m/2 和 m 之间。 所有的叶子结点都在相同的深度。 B-树的平均深度为logm/2(N)。执行查找的平均时间为O(logm)； Trie 树 Trie 树，又称前缀树，字典树， 是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。 Trie 树查询和插入时间复杂度都是 O(n)，是一种以空间换时间的方法。当节点树较多的时候，Trie 树占用的内存会很大。 Trie 树常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。 例题 二叉树的遍历 二叉树前中后序遍历 二叉树的前中后序遍历，使用递归算法实现最为简单，以前序遍历（LeetCode 144）为例： void preorder(TreeNode *p, vector& result) { if (p == NULL) { return; } result.push_back(p->val); preorder(p->left, result); preorder(p->right, result); } vector preorderTraversal(TreeNode* root) { vector result; if (root == nullptr) { return result; } preorder(root, result); return result; } 二叉树的非递归遍历，主要的思想是使用栈（Stack）来进行存储操作，记录经过的节点。 非递归前序遍历（LeetCode 144）： vector preorderTraversal(TreeNode* root) { TreeNode *p = root; vector result; if (!p) { return result; } stack q; while (p || !q.empty()) { if (p) { result.push_back(p->val); q.push(p); p = p->left; } else { p = q.top(); q.pop(); p = p->right; } } return result; } 非递归中序遍历（LeetCode 94）： vector inorderTraversal(TreeNode* root) { TreeNode *p = root; vector result; if (!p) { return result; } stack q; while (p || !q.empty()) { if (p) { q.push(p); p = p->left; } else { p = q.top(); result.push_back(p->val); q.pop(); p = p->right; } } return result; } 非递归遍历中，后序遍历相对更难实现，因为需要在遍历完左右子节点之后，再遍历根节点，因此不能直接将根节点出栈。这里使用一个 last 指针记录上次出栈的节点，当且仅当节点的右孩子为空（top->right == NULL），或者右孩子已经出栈（top->right == last），才将本节点出栈： 非递归后序遍历（LeetCode 145）： vector postorderTraversal(TreeNode* root) { TreeNode *p = root; vector result; if (!p) { return result; } TreeNode *top, *last = NULL; stack q; while (p || !q.empty()) { if (p) { q.push(p); p = p->left; } else { top = q.top(); if (top->right == NULL || top->right == last) { q.pop(); result.push_back(top->val); last = top; } else { p = top->right; } } } return result; } 二叉树层序遍历 LeetCode 102 二叉树层序遍历有两种方法，分别是深度优先和广度优先： 深度优先（DFS）实现： void traversal(TreeNode *root, int level, vector> &result) { if (!root) { return; } // 保证每一层只有一个vector if (level > result.size()) { result.push_back(vector()); } result[level-1].push_back(root->val); traversal(root->left, level+1, result); traversal(root->right, level+1, result); } vector > levelOrder(TreeNode *root) { vector> result; traversal(root, 1, result); return result; } 广度优先（BFS）实现： vector> levelOrder(TreeNode* root) { std:queue q; TreeNode *p; vector> result; if (root == NULL) return result; q.push(root); while (!q.empty()) { int size = q.size(); vector levelResult; for (int i = 0; i val); if (p->left) { q.push(p->left); } if (p->right) { q.push(p->right); } } result.push_back(levelResult); } return result; } 二叉树子树 LeetCode 572 判断二叉树是否是另一棵二叉树的子树，使用递归实现： bool isSubtree(TreeNode* s, TreeNode* t) { if (!s) return false; if (sameTree(s, t)) return true; return isSubtree(s->left, t) || isSubtree(s->right, t); } bool sameTree(TreeNode* s, TreeNode* t) { if (!s && !t) return true; if (!s || !t) return false; if (s->val != t->val) return false; return sameTree(s->left, t->left) && sameTree(s->right, t->right); } 翻转二叉树 LeetCode 226 交互树的左右儿子节点，使用递归实现： TreeNode* invertTree(TreeNode* root) { if (root == nullptr) { return nullptr; } TreeNode *tmp = root->left; root->left = root->right; root->right = tmp; if (root->left) { invertTree(root->left); } if (root->right) { invertTree(root->right); } return root; } 参考资料 百度百科：哈弗曼树 百度百科：二叉排序树 百度百科：平衡二叉树 平衡二叉树及其应用场景 百度百科：B-树 前缀树 百度百科：前缀树 var className='atoc';"},"Basic/Algorithm/DP.html":{"url":"Basic/Algorithm/DP.html","title":"动态规划","keywords":"","body":"动态规划 动态规划 建议观看 MIT 算法导论-动态规划中的课程。 适用于动态规划的问题，需要满足最优子结构和无后效性，动态规划的求解过程，在于找到状态转移方程，进行自底向上的求解。 例题 爬楼梯问题 LeetCode 70 经典的动态规划问题之一，容易找到其状态转移方程为 dp[i] = dp[i-1] + dp[i-2]，从基础的 1 和 2 个台阶两个状态开始，自底向上求解： int climbStairs(int n) { if (n == 1) { return 1; } int* dp = new int[n+1](); dp[1] = 1; dp[2] = 2; for (int i = 3; i 从上面的代码中看到，dp[i] 只依赖 dp[i-1] 和 dp[i-2]，因此可以将代码简化： int climbStairs(int n) { int f0 = 1, f1 = 1, i, f2; for (i=2; i 容易看出其实结果就是 fibonacci 数列的第 n 项。 连续子数组的最大和 LeetCode 53 用 dp[n] 表示元素 n 作为末尾的连续序列的最大和，容易想到状态转移方程为dp[n] = max(dp[n-1] + num[n], num[n])，从第 1 个元素开始，自顶向上求解： int maxSubArray(vector& nums) { int* dp = new int[nums.size()](); dp[0] = nums[0]; int result = dp[0]; for (int i = 1; i 类似前一个问题，这个问题当中，求解 dp[i] 只依赖 dp[i-1]，因此可以使用变量来存储，简化代码： int maxSubArray(int A[], int n) { int result = INT_MIN; int f = 0; for (int i=0; i House Robber LeetCode 198 对于一个房子，有抢和不抢两种选择，容易得到状态转移方程 dp[i+1] = max(dp[i-1] + nums[i], dp[i])，示例代码如下： int rob(vector& nums) { int n = nums.size(); if (n == 0) { return 0; } vector dp = vector(n + 1); dp[0] = 0; dp[1] = nums[0]; for (int i = 1; i 同样的，可以使用两个变量简化代码： int rob(vector& nums) { int n = nums.size(); if (n == 0) { return 0; } int prev1 = 0; int prev2 = 0; for (int i = 0; i 最长回文子串 LeetCode 5 用 dp[i][j] 表示子串 i 到 j 是否是回文，使用动态规划求解： string longestPalindrome(string s) { int m = s.size(); if (m == 0) { return \"\"; } vector> dp(m, vector(m, 0)); int start = 0; int length = 1; for (int i = 0; i length) { start = i; length = j - i + 1; } } } } return s.substr(start, length); } 最小编辑距离 LeetCode 72 用 dp[i][j] 表示从 word[0..i) 转换到 word[0..j) 的最小操作，使用动态规划求解： int minDistance(string word1, string word2) { int m = word1.size(); int n = word2.size(); vector> dp(m + 1, vector(n + 1, 0)); // 全部删除，操作数量为 i for (int i = 0; i var className='atoc';"},"Basic/MySQL/MySQL基本.html":{"url":"Basic/MySQL/MySQL基本.html","title":"MySQL基本","keywords":"","body":"MySQL基本的用法 增删改查基本 创建数据库 CREATE DATABASE 数据库名; 删除数据库 drop database ; 创建表 CREATE TABLE table_name (column_name column_type); create table if not exists Student ( ID integer primary key autoincrement, Name varchar(128), Age integer, Class interger default 0, RegisterTime datetime, Money float default 0, Birthday date ); 删除表 /// 删表: drop table 表名; drop table if exists 表名; drop table t_student; 插入数据（insert） /// 插入数据: insert into 表名 (字段1, 字段2, …) values (字段1的值, 字段2的值, …); insert into t_student (name, age) values (‘张三’, 10); 更新数据（update） /// update 表名 set 字段1 = 字段1的值, 字段2 = 字段2的值, … ; update t_student set name = ‘jack’, age = 20; 删除数据（delete） ///delete from 表名; // 删除指定ID值为2的记录 delete from t_student where ID=2; // 删除t_student表中所有的记录(慎重) delete from t_student; 查询数据（select） /// select 字段1, 字段2, … from 表名; select * from 表名; select name, age from t_student ; select * from t_student ; 查询进阶 条件查询 Where SELECT field1, field2,...fieldN FROM table_name1, table_name2... [WHERE condition1 [AND [OR]] condition2..... // 条件查询 select * from t_student where age > 10 ; 条件查询 LIKE LIKE 子句中使用百分号 %字符来表示任意字符，类似于UNIX或正则表达式中的星号 *。 如果没有使用百分号 %, LIKE 子句与等号 = 的效果是一样的 SELECT field1, field2,...fieldN FROM table_name WHERE field1 LIKE condition1 [AND [OR]] filed2 = 'somevalue' // 模糊查询 select * from t_student where name like '%张%' or phone like '130%'; like 匹配/模糊匹配，会与 % 和 _ 结合使用 '%a' //以a结尾的数据 'a%' //以a开头的数据 '%a%' //含有a的数据 '_a_' //三位且中间字母是a的 '_a' //两位且结尾字母是a的 'a_' //两位且开头字母是a的 查询表中有多少列 select count(*) from tableName; UNION 操作符 MySQL UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。多个 SELECT 语句会删除重复的数据。 UNION 语句：用于将不同表中相同列中查询的数据展示出来；（不包括重复数据） UNION ALL 语句：用于将不同表中相同列中查询的数据展示出来；（包括重复数据） SELECT 列名称 FROM 表名称 UNION SELECT 列名称 FROM 表名称 ORDER BY 列名称； SELECT 列名称 FROM 表名称 UNION ALL SELECT 列名称 FROM 表名称 ORDER BY 列名称； 分页查询 用SELECT查询时，如果结果集数据量很大，比如几万行数据，放在一个页面显示的话数据量太大，不如分页显示，每次显示100条。要实现分页功能，实际上就是从结果集中显示第1~100条记录作为第1页，显示第101~200条记录作为第2页 SELECT ... FROM ... WHERE ... ORDER BY ... LIMIT ... /// limit N : 返回 N 条记录 /// offset M : 跳过 M 条记录, 默认 M=0, /// limit N,M : 相当于 limit M offset N , 从第 N 条记录开始, 返回 M 条记录 select _column,_column from _table [limit N] [offset M] 我们把结果集分页，每页100条记录。 要获取第1页的记录，可以使用LIMIT 100 OFFSET 0： 如果要查询第2页，那么我们只需要“跳过”头100条记录，也就是对结果集从100条记录开始查询，把OFFSET设定为100： SELECT id, name, gender, score FROM students ORDER BY score DESC LIMIT 100 OFFSET 3; var className='atoc';"},"Program/":{"url":"Program/","title":"iOS相关","keywords":"","body":"记录iOS编程中的点滴 iOS中常用的网站 Apple官方 iOS官方人机交互指南 iOS设备尺寸及分辨率 iOS审核指南 开发者登录 iTunes Connect 苹果API文档 教程 中文版 Apple 官方 Swift 教程 ObjC 中国 Runtime的总结 Category的实现原理 isa指针 OC方法调用过程 OC消息机制 runtime如何实现weak属性 runtime具体应用 runtime性能优化 Runloop的总结 触摸事件传递和响应原理 Runloop与线程 iOS事件响应原理 var className='atoc';"},"Program/iOS/OC/oc简介.html":{"url":"Program/iOS/OC/oc简介.html","title":"Objective-C简介","keywords":"","body":"Objective-C简介 Objective-C是一种通用、高级、面向对象的编程语言。它扩展了标准的ANSI C编程语言，将Smalltalk式的消息传递机制加入到ANSI C中。目前主要支持的编译器有GCC和Clang（采用LLVM作为后端) 特性 具有面向对象的语言特性 封装 继承 多态 具有相当多的动态特性 动态类型（Dynamic typing） 动态绑定（Dynamic binding） 动态加载（Dynamic loding） 语法 在Objective-C中使用C语言代码也是完全合法的。Objective-C被描述为盖在C语言上的薄薄一层，因为Objective-C的原意就是在C语言主体上加入面向对象的特性。Objective-C的面向对象语法源于Smalltalk消息传递风格。所有其他非面向对象的语法，包括变量类型，预处理器（preprocessing），流程控制，函数声明与调用皆与C语言完全一致。但有些C语言语法合法代码在objective-c中表达的意思不一定相同，比如某些布尔表达式，在C语言中返回值为true，但在Objective-C若与true直接相比较，函数将会出错，因为在Objective-C中true的值只表示为1. Hello World #import int main(int argc, char *argv[]) { @autoreleasepool { NSLog(@\"Hello World!\"); } return 0; } 消息传递 Objective-C最大的特色是承自Smalltalk的消息传递模型（message passing），此机制与今日C++式之主流风格差异甚大。Objective-C里，与其说对象互相调用方法，不如说对象之间互相传递消息更为精确。此二种风格的主要差异在于调用方法/消息传递这个动作。C++里类别与方法的关系严格清楚，一个方法必定属于一个类别，而且在编译时（compile time）就已经紧密绑定，不可能调用一个不存在类别里的方法。但在Objective-C，类别与消息的关系比较松散，调用方法视为对对象发送消息，所有方法都被视为对消息的回应。所有消息处理直到执行时（runtime）才会动态决定，并交由类别自行决定如何处理收到的消息。也就是说，一个类别不保证一定会回应收到的消息，如果类别收到了一个无法处理的消息，程序只会抛出异常，不会出错或崩溃。 C++里，送一个消息给对象（或者说调用一个方法）的语法如下： obj.method(argument); Objective-C则写成： [obj method: argument]; 此二者并不仅仅是语法上的差异，还有基本行为上的不同。 这里以一个汽车类（car class）的简单例子来解释Objective-C的消息传递特性： [car fly]; 类的定义与实现 Objective-C中强制要求将类的接口（interface）与实现（implementation）分为两个部分。 类的定义文件遵循C语言之惯例以.h为后缀，实现文件以.m为后缀。 接口 定义部分，清楚定义了类的名称、成员变量和方法。 以关键字@interface作为开始，@end作为结束。 @interface MyObject : NSObject { int memberVar1; // 实体变量 id memberVar2; } +(return_type) class_method; // 类方法 -(return_type) instance_method1; // 实例方法 -(return_type) instance_method2: (int) p1; -(return_type) instance_method3: (int) p1 andPar: (int) p2; @end 方法前面的 +/- 号代表函数的类型：加号（+）代表类方法（class method），不需要实例就可以调用，与C++ 的静态函数（static member function）相似。减号（-）即是一般的实例方法（instance method）。 Objective-C定义一个新的方法时，名称内的冒号（:）代表参数传递，不同于C语言以数学函数的括号来传递参数。Objective-C方法使得参数可以夹杂于名称中间，不必全部附缀于方法名称的尾端，可以提高程序可读性。设定颜色RGB值的方法为例： - (void) setColorToRed: (float)red Green: (float)green Blue:(float)blue; /* 宣告方法*/ [myColor setColorToRed: 1.0 Green: 0.8 Blue: 0.2]; /* 呼叫方法*/ 这个方法的签名是setColorToRed:Green:Blue:。每个冒号后面都带着一个float类别的参数，分别代表红，绿，蓝三色。 实现 实现区段则包含了公开方法的实现，以及定义私有（private）变量及方法。 以关键字@implementation作为区段起头，@end结尾。 @implementation MyObject { int memberVar3; /// 私有变量 } +(return_type) class_method { .... //method implementation } -(return_type) instance_method1 { .... } -(return_type) instance_method2: (int) p1 { .... } -(return_type) instance_method3: (int) p1 andPar: (int) p2 { .... } @end var className='atoc';"},"Program/iOS/OC/import第三方库.html":{"url":"Program/iOS/OC/import第三方库.html","title":"import 第三方库头文件总结","keywords":"","body":"Objective-C import 第三方库头文件总结 当我们的 iOS 工程要引用其它第三方开源库时，一般有以下几种方式： （1）下载源代码直接拖拽到工程中； （2）使用 CocoaPods 管理，当开启 use_frameworks! 标记时，第三方库会被编译成 .framework 引入工程，否则就会编译成 .a 静态库； （3）使用 Carthage 管理，第三方库会被编译成 .framework 然后导入工程； （4）直接下载作者编译好的 .framework 导入工程。 但当我们在代码中要 import 第三方库的头文件时，对于这几种情况，写法都不太一样，以 AFNetworking 为例，总结如下： 对于（1）拖拽源码，只能以 \"\" 引号的方式 import， #import \"AFNetworking.h\" 对于（2）CocoaPods，如果开启 use_frameworks!，则将编译成 .framework 库，只能以 <> 尖括号的方式 import，此外，对于（3）和（4）也是这样， #import 而对于 CocoaPods，如果不开启 use_frameworks!，则将编译成 .a 库，此时有如下 3 种方式 import， #import \"AFNetworking.h\" // 或者 #import // 或者 #import 那么问题来了，如果我们在写一个 SDK 或者私有的 Pods 库，需要宿主 App 工程引用某一个第三方库，如上所述，宿主工程有很多方式引用第三方库，这样我们就无法确定应该以哪种方式 import 头文件，怎么办呢？这时候我们就可以使用 __has_include() 宏来判断。 __has_include() 宏接收一个预引入的头文件名称（引号或者尖括号都可以）作为参数，如果该头文件能够被引入则返回 1，否则返回 0，使用起来如下： #if __has_include() #import #else #import \"AFNetworking.h\" #endif var className='atoc';"},"Program/iOS/OC/Xcode技巧.html":{"url":"Program/iOS/OC/Xcode技巧.html","title":"Xcode技巧和快捷键","keywords":"","body":"Xcode技巧 快捷键总结 在目录结构中定位文件 command + shfit + J 选中自动对齐 control + i 快速打开文件方法 command + shift + o 多行光标（使用鼠标）shift + control + click / ⇧ + ⌃ + click 多行光标（使用键盘）shift + control + up or down /⇧ + ⌃ + ↑ or ↓ 多行光标快速初始化 返回光标之前所在的位置 option + command + L / ⌥ + ⌘ + L 跳到某一行 command + L / ⌘ + L 快速打开偏好设置 command + , / ⌘ + , 移动快捷键 上移： command + option + [ 下移： command + option + ] 左移： command + [ 右移： command + ] 快速重命名变量 Cmd + Ctrl + E 按住Alt 选中不同行，可以同时编辑多行 Xcode配置常用变量 使用$(xxx) 这种方式来使用如: $(SRCROOT) 名称 说明 ~ 当前帐户的HOME目录 BUILD_PATH 基础构建目录 BUILD_DIR 构建目录 BUILD_ROOT 构建根目录 PROJECT 项目名称 PROJECT_NAME 项目显示名称 PROJECT_DIR 项目绝对目录 PROJECT_FILE_PATH 项目文件目录${PROJECT_DIR}/*.xcodeproj SOURCE_ROOT ${PROJECT_DIR}源码根目录 SRCROOT .xcodeproj所在目录 TARGET_NAME 目标工程名称 USER 登陆系统的用户名 CONFIGURATION 配置类型,”Debug” 或 “Release” CONFIGURATION_BUILD_DIR 配置构建目录 系统常用宏说明 宏名称 说明 __FILE__ 当前文件所在目录 __FUNCTION__ 当前函数名称 __LINE__ 当前语句在源文件中的行数 __TIME__ 编译时间的字符串，格式为“hh:mm:ss” __STDC__ 整数常量1，表示此编译器遵循ISOC标准 __DATE__ 编译日期的字符串,格式为“mm dd yyyy” XCode中类模板预定义宏变量 宏变量 说明 ___FILENAME___ 文件名,包括扩展名 如 abc.h ___FILEBASENAMEASIDENTIFIER___ 文件名, 不包括扩展名, 如 abc ___PROJECTNAME___ 项目名称 ___USERNAME___ 用户名称 ___FULLUSERNAME___ 用户名全称 ___ORGANIZATIONNAME___ 公司名称 ___DATE___ 基础构建目录 ___FILEBASENAMEASIDENTIFIER___ 日期, 如 21/11/25 ___TIME___ 时间, 如 下午2:30 ___YEAR___ 四位数的年限 如 2015 var className='atoc';"},"Program/iOS/OC/OC的类和对象.html":{"url":"Program/iOS/OC/OC的类和对象.html","title":"OC的类和对象","keywords":"","body":"OC的类和对象 类方法 OC中类的方法只有实例方法和静态方法两种： @interface Controller : NSObject + (void)thisIsAStaticMethod; // 静态方法 – (void)thisIsAnInstanceMethod; // 实例方法 @end OC 中的方法只要声明在 @interface里，就可以认为都是公有的。实际上，OC 没有像 Java，C++ 中的那种绝对的私有及保护成员方法，仅仅可以对调用者隐藏某些方法。 声明和实现都写在 @implementation 里的方法，类的外部是看不到的。 可以使用 Category 来实现私有方法： // AClass.h @interface AClass : NSObject -(void)sayHello; @end // AClass.m @interface AClass (private) -(void)privateSayHello; @end @implementation AClass -(void)sayHello { [self privateSayHello]; } -(void)privateSayHello { NSLog(@\"Private Hello\"); } 使用这种方法时，外部就不能直接调用到 privateSayHello 方法。 注意在上面的代码里面，当我们想通过 Category 来进行方法隐藏的时候，我们可以把实现放在主 implementation 里。当我们想扩展别的不能获取到源代码的类，或者想把不同 Category 的实现分开，可以新建 +CategoryName.m 文件，在里面进行实现： #import \"SystemClass+CategoryName.h\" @implementation SystemClass ( CategoryName ) // method definitions @end 也可以使用 Extension 来实现私有方法： // AClass.h 与上面相同 // AClass.m @interface AClass() -(void)privateSayHello; @end @implementation AClass -(void)sayHello { [self privateSayHello]; } -(void)privateSayHello { NSLog(@\"Private Hello\"); } @end 与使用 Category 类似，由于声明隐藏在 .m 中，调用者无法看到其声明，也就无法调用 privateSayHello 这个方法，会引发编译错误。 关于 Category 和 Extension 的一些区别，在这里。 类变量 苹果推荐在现代 Objective-C 中使用 @property 来实现成员变量： @interface AClass : NSObject @property (nonatomic, copy) NSString *name; @end 使用 @property 声明的变量可以使用实例名.变量名来获取和修改。 @property 可以看做是一种语法糖，在 MRC 下，使用 @property 可以看成实现了下面的代码： // AClass.h @interface AClass : NSObject{ @public NSString *_name; } -(NSString*)name; -(void)setName:(NSString*)newName; @end // AClass.m @implementation AClass -(NSString*)name{ return _name; } -(void)setName:(NSString *)name{ if (_name != name) { [_name release]; _name = [name copy]; } } @end 也就是说，@property 会自动生成 getter 和 setter， 同时进行自动内存管理。 @property 的属性可以有以下几种： readwrite 是可读可写特性；需要生成 getter 方法和 setter 方法 readonly 是只读特性，只会生成 getter 方法 不会生成 setter 方法，不希望属性在类外改变时使用 assign 是赋值特性，setter 方法将传入参数赋值给实例变量；仅设置变量时； retain 表示持有特性，setter 方法将传入参数先保留，再赋值，传入参数的 retain count 会+1; copy 表示拷贝特性，setter 方法将传入对象复制一份；需要完全一份新的变量时。 nonatomic 和 atomic ，决定编译器生成的 setter getter是否是原子操作。 atomic 表示使用原子操作，可以在一定程度上保证线程安全。一般推荐使用 nonatomic ，因为 nonatomic 编译出的代码更快 默认的 @property 是 readwrite，assign，atomic。 同时，我们还可以使用自己定义 accessor 的名字： @property (getter=isFinished) BOOL finished; 这种情况下，编译器生成的 getter 方法名为 isFinished，而不是 finished。 @synthesize 和 @dynamic 对于现代 OC 来说，在使用 @property 时， 编译器默认会进行自动 synthesize，生成 getter 和 setter，同时把 ivar 和属性绑定起来： /// 现代 OC 不再需要手动进行下面的声明，编译器会自动处理 @synthesize propertyName = _propertyName 不需要我们写任何代码，就可以直接使用 getter 和 setter 了。 然而并不是所有情况下编译器都会进行自动 synthesize，具体由下面几种： 可读写(readwrite)属性实现了自己的 getter 和 setter 只读(readonly)属性实现了自己的 getter 使用 @dynamic，显式表示不希望编译器生成 getter 和 setter protocol 中定义的属性，编译器不会自动 synthesize，需要手动写 当重载父类中的属性时，也必须手动写 synthesize 类的扩展——Protocol, Category 和 Extension Protocol OC是单继承的，OC中的类可以实现多个 protocol 来实现类似 C++ 中多重继承的效果。 Protocol 类似 Java 中的 interface，定义了一个方法列表，这个方法列表中的方法可以使用 @required， @optional 标注，以表示该方法是否是客户类必须要实现的方法。 一个 protocol 可以继承其他的 protocol 。 @protocol TestProtocol // NSObject也是一个 Protocol，这里即继承 NSObject 里的方法 -(void)print; @end @interface B : NSObject -(void)print; // 默认方法是 @required 的，即必须实现 @end Delegate（委托）是 Cocoa 中常见的一种设计模式，其实现依赖于 protocol 这个语言特性。 含有 property 的 Protocol 上面提到过，当 Protocol 中含有 property 时，编译器是不会进行自动 synthesize 的，需要手动处理： @class ExampleClass; @protocol ExampleProtocol @required @property (nonatomic, retain) ExampleClass *item; @end 在实现这个 Protocol 的时候，要么再次声明 property： @interface MyObject : NSObject @property (nonatomic, retain) ExampleClass *item; @end 要么进行手动 synthesize： @interface MyObject : NSObject @end @implementation MyObject @synthesize item; @end 工程自带的 AppDelegate 使用了前一种方法，UIApplicationDelegate protocol 当中定义了 window 属性： @property (nonatomic, retain) UIWindow *window NS_AVAILABLE_IOS(5_0); 在 AppDelegate.h 中我们可以看到再次对 windows 进行了声明： @interface AppDelegate : UIResponder @property (nonatomic, strong) UIWindow *window; @end Category Category 是一种很灵活的扩展原有类的机制，使用 Category 不需要访问原有类的代码，也无需继承。Category提供了一种简单的方式，来实现类的相关方法的模块化，把不同的类方法分配到不同的类文件中。 Category 常见的使用方法如下： // SomeClass.h @interface SomeClass : NSObject{ } -(void)print; @end // SomeClass+Hello.h #import \"SomeClass.h\" @interface SomeClass (Hello) -(void)hello; @end // 实现 #import \"SomeClass+Hello.h\" @implementationSomeClass (Hello) -(void)hello{ NSLog(@\"name：%@ \", @\"Jacky\"); } @end 在使用 Category 时需要注意的一点是，如果有多个命名 Category 均实现了同一个方法（即出现了命名冲突），那么这些方法在运行时只有一个会被调用，具体哪个会被调用是不确定的。因此在给已有的类（特别是 Cocoa 类）添加 Category 时，推荐的函数命名方法是加上前缀： @interface NSSortDescriptor (XYZAdditions) + (id)xyz_sortDescriptorWithKey:(NSString *)key ascending:(BOOL)ascending; @end Extension Extension 可以认为是一种匿名的 Category， Extension 与 Category 有如下几点显著的区别： 使用 Extension 必须有原有类的源码 Extension 声明的方法必须在类的主 @implementation 区间内实现，可以避免使用有名 Category 带来的多个不必要的 implementation 段。 Extension 可以在类中添加新的属性和实例变量，Category 不可以（注：在 Category 中实际上可以通过运行时添加新的属性，下面会讲到） Extension 里添加的方法必须要有实现（没有实现编译器会给出警告） 注：现代 ObjC 中 Extension 和 Category 中声明的方法如果没有实现编译器都会给出警告。 下面是一个 Extension 的例子： @interface MyClass : NSObject - (float)value; @end @interface MyClass () { // 注意此处扩展的写法 float value; } - (void)setValue:(float)newValue; @end @implementation MyClass - (float)value { return value; } - (void)setValue:(float)newValue { value = newValue; } @end Extension 很常见的用法，是用来给类添加私有的变量和方法，用于在类的内部使用。例如在 interface 中定义为 readonly 类型的属性，在实现中添加 extension，将其重新定义为 readwrite，这样我们在类的内部就可以直接修改它的值，然而外部依然不能调用 setter 方法来修改。示例代码如下（来自苹果官方文档）: XYZPerson.h @interface XYZPerson : NSObject ... @property (readonly) NSString *uniqueIdentifier; @end XYZPerson.m @interface XYZPerson () @property (readwrite) NSString *uniqueIdentifier; @end @implementation XYZPerson ... @end 如何给已有的类添加属性 首先强调一下上面例子中所展示的，Extension 可以给类添加属性，编译器会自动生成 getter，setter 和 ivar。 Category 并不支持这些。如果使用 Category 的话，类似下面这样： @interface XYZPerson (UDID) @property (readwrite) NSString *uniqueIdentifier; @end @implementation XYZPerson (UDID) ... @end 尽管编译可以通过，但是当真正使用 uniqueIdentifier 时直接会导致程序崩溃。 如果我们手动去 synthesize 呢？像下面这样： @implementation XYZPerson (UDID) @synthesize uniqueIdentifier; ... @end 然而这样做的话，代码直接报编译错误了： @synthesize not allowed in a category's implementation 看来这条路是彻底走不通了。 不过我们还有别的方法，想通过 Category 添加属性的话，可以通过 Runtime 当中提供的 associated object 特性。NSHipster 的 这篇文章 展示了具体的做法。 如何在类中添加全局变量 有些时候我们需要在类中添加某个在类中全局可用的变量，为了避免污染作用域，一个比较好的做法是在 .m 文件中使用 static 变量： static NSOperationQueue * _personOperationQueue = nil; @implementation XYZPerson ... @end 由于 static 变量在编译期就是确定的，因此对于 NSObject 对象来说，初始化的值只能是 nil。如何进行类似 init 的初始化呢？可以通过重载 initialize 方法来做： @implementation XYZPerson - (void)initialize { if (!_personOperationQueue) { _personOperationQueue = [[NSOperationQueue alloc] init]; } } @end 为什么这里要判断是否为 nil 呢？因为 initialize 方法可能会调用多次，后面会提到。 如果是在 Category 中想声明全局变量呢？当然也可以通过 initialize，不过除非必须的情况下，并不推荐在 Category 当中进行方法重载。 有一种方法是声明 static 函数，下面的代码来自 AFNetworking，声明了一个当前文件范围可用的队列： static dispatch_queue_t url_session_manager_creation_queue() { static dispatch_queue_t af_url_session_manager_creation_queue; static dispatch_once_t onceToken; dispatch_once(&onceToken, ^{ af_url_session_manager_creation_queue = dispatch_queue_create(\"com.alamofire.networking.session.manager.creation\", DISPATCH_QUEUE_SERIAL); }); return af_url_session_manager_creation_queue; } 下面介绍一个有点黑魔法的方法，除了上面两种方法之外，我们还可以通过编译器的 __attribute__ 特性来实现初始化： __attribute__((constructor)) static void initialize_Queue() { _personOperationQueue = [[NSOperationQueue alloc] init]; } @implementation XYZPerson (Operation) @end 类的导入 导入类可以使用 #include , #import 和 @class 三种方法，其区别如下： #import是Objective-C导入头文件的关键字，#include是C/C++导入头文件的关键字 使用#import头文件会自动只导入一次，不会重复导入，相当于#include和#pragma once； @class告诉编译器需要知道某个类的声明，可以解决头文件的相互包含问题； @class是放在interface中的，只是在引用一个类，将这个被引用类作为一个类型使用。在实现文件中，如果需要引用到被引用类的实体变量或者方法时，还需要使用#import方式引入被引用类。 类的初始化 Objective-C 是建立在 Runtime 基础上的语言，类也不例外。OC 中类是初始化也是动态的。在 OC 中绝大部分类都继承自 NSObject，它有两个非常特殊的类方法 load 和 initilize，用于类的初始化 +load +load 方法是当类或分类被添加到 Objective-C runtime 时被调用的，实现这个方法可以让我们在类加载的时候执行一些类相关的行为。子类的 +load 方法会在它的所有父类的 +load 方法之后执行，而分类的 +load 方法会在它的主类的 +load 方法之后执行。但是不同的类之间的 +load 方法的调用顺序是不确定的。 load 方法不会被类自动继承, 每一个类中的 load 方法都不需要像 viewDidLoad 方法一样调用父类的方法。子类、父类和分类中的 +load 方法的实现是被区别对待的。也就是说如果子类没有实现 +load 方法，那么当它被加载时 runtime 是不会去调用父类的 +load 方法的1。同理，当一个类和它的分类都实现了 +load 方法时，两个方法都会被调用。因此，我们常常可以利用这个特性做一些“邪恶”的事情，比如说方法混淆（Method Swizzling）。FDTemplateLayoutCell 中就使用了这个方法，见这里。 +initialize +initialize 方法是在类或它的子类收到第一条消息之前被调用的，这里所指的消息包括实例方法和类方法的调用。也就是说 +initialize 方法是以懒加载的方式被调用的，如果程序一直没有给某个类或它的子类发送消息，那么这个类的 +initialize 方法是永远不会被调用的。 +initialize 方法的调用与普通方法的调用是一样的，走的都是发送消息的流程。换言之，如果子类没有实现 +initialize 方法，那么继承自父类的实现会被调用；如果一个类的分类实现了 +initialize 方法，那么就会对这个类中的实现造成覆盖。 注解 1.举一个例子：有一个 Father 类，实现了 load 方法，打印类名，一个 Son 类继承自前者，没有实现 load 方法。实例出一个 Son 的对象时，结果是会输出父类的名字。但这个例子与之前的结论并不矛盾，这里说的是父类先被加载了，所以调用了父类的 load 方法，而子类被加载时没有调用父类的 load 方法。 暂时没找到例子可以严格的证明此前的结论，所以还是去看源码吧。↩ var className='atoc';"},"Program/iOS/OC/Block总结.html":{"url":"Program/iOS/OC/Block总结.html","title":"Block总结","keywords":"","body":"Block总结 Block 语法 Block 可以认为是一种匿名函数，使用如下语法声明一个 Block 类型： return_type (^block_name)(parameters) 例如： double (^multiplyTwoValues)(double, double); Block 字面值的写法如下： ^ (double firstValue, double secondValue) { return firstValue * secondValue; } 上面的写法省略了返回值的类型，也可以显式地指出返回值类型。 声明并且定义完一个Block之后，便可以像使用函数一样使用它： double (^multiplyTwoValues)(double, double) = ^(double firstValue, double secondValue) { return firstValue * secondValue; }; double result = multiplyTwoValues(2,4); NSLog(@\"The result is %f\", result); 同时，Block 也是一种 Objective-C 对象，可以用于赋值，当做参数传递，也可以放入 NSArray 和 NSDictionary 中。 注意：当用于函数参数时，Block 应该放在参数列表的最后一个。 Bonus： 由于Block的语法不好记，有个神奇的网站专门记录了Block的语法 How Do I Declare A Block in Objective-C? 点击查看OC中Block的定义说明 作为变量: returnType (^blockName)(parameterTypes) = ^returnType(parameters) {...}; 作为属性: @property (nonatomic, copy) returnType (^blockName)(parameterTypes); 作为函数声明中的参数: - (void)someMethodThatTakesABlock:(returnType (^)(parameterTypes))blockName; 作为函数调用中的参数: [someObject someMethodThatTakesABlock:^returnType (parameters) {...}]; 作为 typedef: typedef returnType (^TypeName)(parameterTypes); TypeName blockName = ^returnType(parameters) {...}; Block 可以捕获外部变量 Block 可以捕获来自外部作用域的变量，这是Block一个很强大的特性。 - (void)testMethod { int anInteger = 42; void (^testBlock)(void) = ^{ NSLog(@\"Integer is: %i\", anInteger); }; testBlock(); } 默认情况下，Block 中捕获的到变量是不能修改的，如果想修改，需要使用__block来声明： __block int anInteger = 42; 对于 id 类型的变量，在 MRC 情况下，使用 __block id x 不会 retain 变量，而在 ARC 情况下则会对变量进行 retain（即和其他捕获的变量相同）。如果不想在 block 中进行 retain 可以使用 __unsafe_unretained __block id x，不过这样可能会导致野指针出现。更好的办法是使用 __weak 的临时变量： MyViewController *myController = [[MyViewController alloc] init…]; // ... MyViewController * __weak weakMyViewController = myController; myController.completionHandler = ^(NSInteger result) { [weakMyViewController dismissViewControllerAnimated:YES completion:nil]; }; 或者把使用 __block 修饰的变量设为 nil，以打破引用循环： MyViewController * __block myController = [[MyViewController alloc] init…]; // ... myController.completionHandler = ^(NSInteger result) { [myController dismissViewControllerAnimated:YES completion:nil]; myController = nil; }; 使用 Block 时的注意事项 在非 ARC 的情况下，对于 block 类型的属性应该使用 copy ，因为 block 需要维持其作用域中捕获的变量。在 ARC 中编译器会自动对 block 进行 copy 操作，因此使用 strong 或者 copy 都可以，没有什么区别，但是苹果仍然建议使用 copy 来指明编译器的行为。 block 在捕获外部变量的时候，会保持一个强引用，当在 block 中捕获 self 时，由于对象会对 block 进行 copy，于是便形成了强引用循环： @interface XYZBlockKeeper : NSObject @property (copy) void (^block)(void); @end @implementation XYZBlockKeeper - (void)configureBlock { self.block = ^{ [self doSomething]; // capturing a strong reference to self // creates a strong reference cycle }; } ... @end 为了避免强引用循环，最好捕获一个 self 的弱引用： - (void)configureBlock { XYZBlockKeeper * __weak weakSelf = self; self.block = ^{ [weakSelf doSomething]; // capture the weak reference // to avoid the reference cycle } } 使用弱引用会带来另一个问题，weakSelf 有可能会为 nil，如果多次调用 weakSelf 的方法，有可能在 block 执行过程中 weakSelf 变为 nil。因此需要在 block 中将 weakSelf “强化“ __weak __typeof__(self) weakSelf = self; NSBlockOperation *op = [[[NSBlockOperation alloc] init] autorelease]; [ op addExecutionBlock:^ { __strong __typeof__(self) strongSelf = weakSelf; [strongSelf doSomething]; [strongSelf doMoreThing]; } ]; [someOperationQueue addOperation:op]; __strong 这一句在执行的时候，如果 WeakSelf 还没有变成 nil，那么就会 retain self，让 self 在 block 执行期间不会变为 nil。这样上面的 doSomething 和 doMoreThing 要么全执行成功，要么全失败，不会出现一个成功一个失败，即执行到中间 self 变成 nil 的情况。 Bonus 很多文章对于 weakSelf 的解释中并没有详细说，为什么有可能 block 执行的过程当中 weakSelf 变为 nil，这就涉及到 weak 本身的机制了。weak 置 nil 的操作发生在 dealloc 中，苹果在 TN2109 - The Deallocation Problem 中指出，最后一个持有 object 的对象被释放的时候，会触发对象的 dealloc，而这个持有者的释放操作就不一定保证发生在哪个线程了。因此 block 执行的过程中 weakSelf 有可能在另外的线程中被置为 nil。 Block 在堆上还是在栈上？ 首先要指出，Block 在非 ARC 和 ARC 两种环境下的内存机制差别很大。 在 MRC 下，Block 默认是分配在栈上的，除非进行显式的 copy： __block int val = 10; blk stackBlock = ^{NSLog(@\"val = %d\", ++val);}; NSLog(@\"stackBlock: %@\", stackBlock); // stackBlock: tempBlock = [stackBlock copy]; NSLog(@\"tempBlock: %@\", tempBlock); // tempBlock: 想把 Block 用作返回值的时候，也要加入 copy 和 autorelease： - (blk)myTestBlock { __block int val = 10; blk stackBlock = ^{NSLog(@\"val = %d\", ++val);}; return [[stackBlock copy] autorelease]; } 在 ARC 环境下，Block 使用简化了很多，同时 ARC 也更加倾向于把 Block 放到堆上： __block int val = 10; __strong blk strongPointerBlock = ^{NSLog(@\"val = %d\", ++val);}; NSLog(@\"strongPointerBlock: %@\", strongPointerBlock); // strongPointerBlock: __weak blk weakPointerBlock = ^{NSLog(@\"val = %d\", ++val);}; NSLog(@\"weakPointerBlock: %@\", weakPointerBlock); // weakPointerBlock: NSLog(@\"mallocBlock: %@\", [weakPointerBlock copy]); // mallocBlock: NSLog(@\"test %@\", ^{NSLog(@\"val = %d\", ++val);}); // test 可以看到只有显式的 __weak 以及纯匿名 Block 是放到栈上的，赋值给 __strong 指针（也就是默认赋值）都会导致在堆上创建 Block。 对于把 Block 作为函数返回值的情况，ARC 也能自动处理： - (__unsafe_unretained blk) blockTest { int val = 11; return ^{NSLog(@\"val = %d\", val);}; } NSLog(@\"block return from function: %@\", [self blockTest]); // block return from function: var className='atoc';"},"Program/iOS/OC/OC内存管理.html":{"url":"Program/iOS/OC/OC内存管理.html","title":"OC内存管理","keywords":"","body":"OC内存管理 var className='atoc';"},"Program/iOS/OC/Category实现原理.html":{"url":"Program/iOS/OC/Category实现原理.html","title":"Category的实现原理","keywords":"","body":"Category实现原理 var className='atoc';"},"Program/iOS/OC/isa指针.html":{"url":"Program/iOS/OC/isa指针.html","title":"isa指针","keywords":"","body":"isa指针 var className='atoc';"},"Program/iOS/OC/OC方法调用过程.html":{"url":"Program/iOS/OC/OC方法调用过程.html","title":"OC方法调用过程","keywords":"","body":"OC方法调用过程 var className='atoc';"},"Program/iOS/OC/OC消息机制.html":{"url":"Program/iOS/OC/OC消息机制.html","title":"OC消息机制","keywords":"","body":"OC消息机制 var className='atoc';"},"Program/iOS/OC/runtime如何实现weak属性.html":{"url":"Program/iOS/OC/runtime如何实现weak属性.html","title":"runtime如何实现weak属性","keywords":"","body":"runtime 如何实现 weak 属性 var className='atoc';"},"Program/iOS/OC/runtime具体应用.html":{"url":"Program/iOS/OC/runtime具体应用.html","title":"runtime具体应用","keywords":"","body":"runtime具体应用 var className='atoc';"},"Program/iOS/OC/runtime性能优化.html":{"url":"Program/iOS/OC/runtime性能优化.html","title":"runtime性能优化","keywords":"","body":"runtime性能优化 var className='atoc';"},"Program/iOS/OC/触摸事件传递和响应原理.html":{"url":"Program/iOS/OC/触摸事件传递和响应原理.html","title":"触摸事件传递和响应原理","keywords":"","body":"iOS中触摸事件传递和响应原理 var className='atoc';"},"Program/iOS/OC/Runloop与线程.html":{"url":"Program/iOS/OC/Runloop与线程.html","title":"Runloop与线程","keywords":"","body":"Runloop与线程 var className='atoc';"},"Program/iOS/OC/iOS事件响应原理.html":{"url":"Program/iOS/OC/iOS事件响应原理.html","title":"iOS事件响应原理","keywords":"","body":"iOS事件响应原理 var className='atoc';"},"Program/iOS/Swift/syntax/swift简介.html":{"url":"Program/iOS/Swift/syntax/swift简介.html","title":"swift简介","keywords":"","body":"swift简介 var className='atoc';"},"Program/iOS/Tool/工欲善其事必先利其器之Xcode.html":{"url":"Program/iOS/Tool/工欲善其事必先利其器之Xcode.html","title":"工欲善其事必先利其器之Xcode","keywords":"","body":"工欲善其事必先利其器之Xcode 再开始编程之前， 先把我们的编辑器工具做下自定义的处理，可以大幅提高我们的效率 代码仓库 代码仓库地址 代码块 Code Snippet是Xcode中的代码块，可以将一些常用的代码添加为Snippet [_tableView registerClass:[ class] forCellReuseIdentifier:NSStringFromClass([ class])]; @property (nonatomic, copy) (^)(); 常用的高频代码等等 Xcode的Snippet 的目录 ~/Library/Developer/Xcode/UserData/CodeSnippets 将Clone下来的项目中的Code Snippet中的文件拖入 ~/Library/Developer/Xcode/UserData/CodeSnippets中即可 FileTemplate文件模板 可以自定义我们新建文件的模板，使我们的文件可以快速初始化成我们固定的模板 #pragma mark - Life cycle - (void)dealloc { NSLog(@\"%@ - dealloc\", NSStringFromClass([self class])); } - (void)viewDidLoad { [super viewDidLoad]; self.title = @\"\"; [self setupSubViews]; [self setupViewLayouts]; } - (void)viewWillAppear:(BOOL)animated { [super viewWillAppear:animated]; } - (void)viewWillDisappear:(BOOL)animated { [super viewWillDisappear:animated]; } - (void)setupSubViews { } - (void)setupViewLayouts { } #pragma mark - Events #pragma mark - UITableViewDataSource #pragma mark - UITableViewDelegate #pragma mark - Public Methods #pragma mark - Private Methods #pragma mark - Setter #pragma mark - Getter Xcode的代码模板路径 /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/Xcode/Templates/File Templates/iOS/Source/Cocoa Touch Class.xctemplate 将Clone下来的项目中的FileTemplate中的文件拖入 该目录即可 OC Extension Foundation中存放一些Cocoa Foundation中常用的扩展类 UIKit中存放一些Cocoa中常用的扩展类 Swift Extension 该目录中存放一些Swift中常用的扩展类 Utils 该目录中存放一些项目中常用的工具类 var className='atoc';"},"Program/iOS/Tool/渐变投影阴影的实现.html":{"url":"Program/iOS/Tool/渐变投影阴影的实现.html","title":"渐变投影阴影的实现","keywords":"","body":"渐变投影阴影的实现 渐变 渐变层在其背景色上绘制颜色渐变，即是填充层的形状（包括圆角），通俗的来说就是根据shape形状来绘制渐变色 CAgradientLayerLayer *gradientLayer = [CAgradientLayerLayer layer]; /// startPoint与endPoint分别为渐变的起始方向与结束方向，它是以矩形的四个角为基础的，（0，0）为左上角、（1，0）为右上角、（0，1）为左下角、（1，1）为右下角，默认是值是（0.5，0）和（0.5，1） gradientLayer.startPoint = CGPointMake(0, 0); gradientLayer.endPoint = CGPointMake(1, 0); gradientLayer.frame = CGRectMake(0, 0, 100, 100); /// 渐变点 gradientLayerLayer.locations = @[@(0.7), @(1.0)]; /// 颜色渐变数组 gradientLayer.colors = @[]; [view.layer insertSublayer:gradientLayer atIndex:0]; 投影 在 iOS 里实现阴影的方式是使用 UIView 的 layer 属性。 layer 里与阴影有关的设置是以下几个属性： shadowPath shadowColor shadowOpacity shadowOffset shadowRadius 与 Sketch 里阴影参数的对应关系是： shadowPath ~> 阴影的范围 shadowColor ~> 阴影的颜色 shadowOpacity ~> 阴影的透明度 shadowOffset ~> X 和 Y shadowRadius ~> 阴影的模糊 ///阴影的颜色 view.layer.shadowColor = [UIColor blackColor].CGColor; ///阴影的透明度 view.layer.shadowOpacity = 0.4f; ///阴影的圆角 view.layer.shadowRadius = 4.0f; ///阴影偏移量 view.layer.shadowOffset = CGSizeMake(0,0);//Defaults to (0, -3). Animatable. var className='atoc';"},"Program/iOS/Tool/Xcode获取打包时间脚本.html":{"url":"Program/iOS/Tool/Xcode获取打包时间脚本.html","title":"Xcode获取打包时间脚本","keywords":"","body":"Xcode运行脚本 run script in build phases： 脚本几乎和shell脚本一样，位置在Xcode的Build Phases配置中添加，属于build阶段，默认会在系统自动build之后，installing app之前执行。 Xcode脚本获取打包时间 操作步骤 在Xcode的Build Phases中点击添加脚本 在项目的文件夹中创建 buildInfo.plist，并添加以BuildTime 为key的字段 在脚本输入框中输入以下代码 #!/bin/sh set -e # plist 文件地址 PLIST_PATH=\"./ProjectName/buildInfo.plist\" BUILD_TIME_KEY=\":BuildTime\" BUILD_TIME_VALUE=\"打包时间:$(date +%m月%d日%H时%M分%S秒)\" if [ -r \"${PLIST_PATH}\" ]; then /usr/libexec/PlistBuddy -c \"Set ${BUILD_TIME_KEY} ${BUILD_TIME_VALUE}\" \"${PLIST_PATH}\" else /usr/libexec/PlistBuddy -c \"Add ${BUILD_TIME_KEY} string ${BUILD_TIME_VALUE}\" \"${PLIST_PATH}\" fi 在代码中读取打包的时间 NSString *filePath = [[NSBundle mainBundle] pathForResource:@\"buildInfo\" ofType:@\"plist\"]; NSDictionary *dict = [NSDictionary dictionaryWithContentsOfFile: filePath]; NSString *buildTime = dict[@\"BuildTime\"]; 每次构建的时候build号自增 添加如下shell脚本 if [ $CONFIGURATION == Release ]; then echo \"当前为 Release Configuration,开始自增 Build\" plist=${INFOPLIST_FILE} buildnum=$(/usr/libexec/PlistBuddy -c \"Print CFBundleVersion\" \"${plist}\") if [[ \"${buildnum}\" == \"\" ]]; then echo \"Error：在Plist文件里没有 Build 值\" exit 2 fi buildnum=$(expr $buildnum + 1) /usr/libexec/PlistBuddy -c \"Set CFBundleVersion $buildnum\" \"${plist}\" else echo $CONFIGURATION \"当前不为 Release Configuration\" fi var className='atoc';"},"Program/iOS/Tool/Xcode脚本打包.html":{"url":"Program/iOS/Tool/Xcode脚本打包.html","title":"Xcode脚本打包","keywords":"","body":"Xcode脚本打包 Python版 打包并上传IPA包到蒲公英，然后发送邮件通知相关人员 import os import datetime import subprocess import requests import smtplib from email.mime.multipart import MIMEMultipart from email.mime.text import MIMEText from email.mime.image import MIMEImage from email.header import Header # config the build settings CONFIGURATION = 'Release' SDK = \"iphoneos\" WORKSPACE = \"TargetName.xcworkspace\" TARGET = \"TargetName\" SCHEME = \"TargetName\" XCARCHIVE_NAME = TARGET + '.xcarchive' PROJECT_PATH = '~/Desktop/code/TargetName' EXPORT_DIRECTORY = '~/desktop/ipa/TargetName' APP_PATH = os.getcwd() + '/build/' + CONFIGURATION + '-iphoneos' APP_FILE_NAME = APP_PATH + TARGET + '.app' KEYCHAIN_PATH = '~/Library/Keychains/login.keychain' KEYCHAIN_PWD = 'password' EXPORT_APP_STORE_PLIST = 'AppStoreOptions.plist' EXPORT_ADHOC_PLIST = 'AdhocOptions.plist' PGYER_UPLOAD_URL = \"http://www.pgyer.com/apiv1/app/upload\" DOWNLOAD_BASE_URL = \"http://www.pgyer.com\" PGYER_API_KEY = '' PGYER_USER_KEY = '' PGYER_APP_KEY = '' PGYER_APP_ID = '' # 邮件相关 SENDER_EMAIL = 'xx@xx.com' RECEIVER_EMAIL = 'xx@xx.com' SENDER_EMAIL_AUTH_CODE = 'authCode' SMTP_SERVER = 'SMTP_SERVER' EMAIL_USER_NAME = 'EMAIL_USER_NAME' PGYER_DOWN_URL = \"https://www.pgyer.com/1Zfu\" RECEIVER_EMAIL_MUTIPLE = ['receiverEmail1', 'receiverEmail2', 'receiverEmail3', 'mreceiverEmail4'] # clean项目 def clean_project(): print('clean project') os.system('cd %s; xcodebuild clean' % PROJECT_PATH) show_notification('clean成功', '正在运行clean方法') return # build编译 def build_project(): archive_path = PROJECT_PATH + '/build/' + XCARCHIVE_NAME build_commond = 'cd %s; xcodebuild archive -workspace %s -scheme %s -sdk %s -configuration %s' \\ ' -archivePath %s' \\ % (PROJECT_PATH, WORKSPACE, SCHEME, SDK, CONFIGURATION, archive_path) print(build_commond) os.system('xcodebuild -list') os.system(build_commond) show_notification('正在编译中', '别着急，正在编译') print('the path of xcarchive is %s' % archive_path) archive_ipa(archive_path) # 打包 def archive_ipa(archive_path): current_date = datetime.datetime.now().strftime(\"%Y-%m-%d-%H:%M:%S\") ipa_path = '%s/%s-%s' % (EXPORT_DIRECTORY, SCHEME, current_date) print(\"\\nexport ipa path is: \" + ipa_path) # 如果不存在文件夹，则创建 if not os.path.isdir(ipa_path): os.system('mkdir %s' % ipa_path) ipa_export_path = ipa_path + '/' # 设置打包类型 export_option_plist = PROJECT_PATH + \"/TargetName/AppDelegate\" + EXPORT_ADHOC_PLIST print(\"adhoc export option plist is: \" + export_option_plist) archive_commmand = 'xcodebuild -exportArchive -archivePath %s -exportPath %s -exportOptionsPlist %s' \\ % (archive_path, ipa_export_path, export_option_plist) print(archive_commmand) show_notification('正在打包中', '别着急，正在打包') os.system(archive_commmand) ipa_file_name = ipa_export_path + TARGET + '.ipa' print(\"ipa file name is \" + ipa_file_name) # 删除archive文件 archive_file_path = PROJECT_PATH + \"/build\" print(\"build archive file path is \" + archive_file_path) if os.path.isdir(archive_file_path) : os.remove(archive_file_path) upload_pgyer(ipa_file_name) # 解析上传蒲公英的结果 def parser_upload_result(json_result): result_code = json_result['code'] if result_code == 0: download_url = DOWNLOAD_BASE_URL + \"/\" + json_result['data']['appShortcutUrl'] print('upload success! url is %s' % download_url) else: print('upload failed! Reason is %s' % json_result['message']) # 上传到蒲公英 def upload_pgyer(ipa_path): ipa_path = os.path.expanduser(ipa_path) files = {'file': open(ipa_path, 'rb')} headers = {'enctype': 'multipart/form-data'} paramater = {'uKey': PGYER_USER_KEY, '_api_key': PGYER_API_KEY} r = requests.post(PGYER_UPLOAD_URL, data=paramater, files=files, headers=headers) if r.status_code == 200: result = r.json() parser_upload_result(result) print(\"蒲公英上传成功了\") show_notification(\"上传蒲公英\",\"上传成功了\") send_email() else: print('上传蒲公英出现了问题，errorcode = %s' % r.status_code) def send_email() : # 设置smtplib所需的参数 # 下面的发件人，收件人是用于邮件传输的。 # receiver='XXX@126.com' # 收件人为多个收件人 receiver = ['huyong229@163.com', '229376483@qq.com'] subject = 'smartOffice 版本更新（此邮件为脚本自动发送）' # 通过Header对象编码的文本，包含utf-8编码信息和Base64编码信息。以下中文名测试ok # subject = '中文标题' # subject=Header(subject, 'utf-8').encode() # 构造邮件对象MIMEMultipart对象 # 下面的主题，发件人，收件人，日期是显示在邮件页面上的。 msg = MIMEMultipart('mixed') msg['Subject'] = subject msg['From'] = '%s ' %(SENDER_EMAIL, SENDER_EMAIL) # msg['From'] = \"系统\" # msg['To'] = 'XXX@126.com' # 收件人为多个收件人,通过join将列表转换为以;为间隔的字符串 msg['To'] = \";\".join(RECEIVER_EMAIL_MUTIPLE) msg['Date']= datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M\") # 构造文字内容 text = \"Hi All\\n\\n APP发布了新版本了! 下载地址是: %s\\n \" %(PGYER_DOWN_URL) text += \"\\n\\n 请重新下载安装\" text += '\\n\\n\\n\\n\\n\\n\\n 如需关闭此邮件提醒，请联系Jack Hu' text_plain = MIMEText(text, 'plain', 'utf-8') msg.attach(text_plain) # 发送邮件 smtp = smtplib.SMTP() smtp.connect('smtp.163.com') # 我们用set_debuglevel(1)就可以打印出和SMTP服务器交互的所有信息。 smtp.set_debuglevel(1) smtp.login(EMAIL_USER_NAME, SENDER_EMAIL_AUTH_CODE) for email in RECEIVER_EMAIL_MUTIPLE: smtp.sendmail(SENDER_EMAIL, email, msg.as_string()) smtp.quit() # 获取权限 def allow_keychain(): os.system(\"security unlock-keychain -p '%s' %s\" % (KEYCHAIN_PWD, KEYCHAIN_PATH)) return # Mac弹出系统通知 def show_notification(title, subtitle): notification = \"osascript -e 'display notification \\\"%s\\\" with title \\\"%s\\\"'\" % (subtitle, title) print(notification) os.system(notification) def main(): print(\"hello\") allow_keychain() clean_project() build_project() if __name__ == '__main__': main() Shell版 #!/bin/sh export LANG=en_US.UTF-8 # 1.设置配置标识,编译环境(根据需要自行填写 release ｜ debug ) configuration=\"debug\" # 工程名(根据项目自行填写) APP_NAME=\"TargetName\" # TARGET名称（根据项目自行填写） TARGET_NAME=\"TargetName\" # ipa前缀（根据项目自行填写） IPA_NAME=\"xx\" # 工程根目录#工程源码目录(这里的${WORKSPACE}是jenkins的内置变量表示(jenkins job的路径):/Users/plz/.jenkins/workspace/TestDome/) # ${WORKSPACE}/TestDome/ 中的TestDome根据你的项目自行修改 CODE_PATH=\"${WORKSPACE}/${TARGET_NAME}\" echo \"-------------- CODE_PATH: ${CODE_PATH}\" # info.plist路径 project_infoplist_path= \"${CODE_PATH}/${TARGET_NAME}/Info.plist\" # 取版本号 bundleShortVersion= $(/usr/libexec/PlistBuddy -c \"print CFBundleShortVersionString\" \"${project_infoplist_path}\") # bundleVersion= $(/usr/libexec/PlistBuddy -c \"print CFBundleVersion\" \"${project_infoplist_path}\") echo \"------- info plist path : ${project_infoplist_path}\" echo \"------- bundleShortVersion : ${bundleShortVersion}\" # 日期 DATE=$(date +%Y%m%d-%H-%M-%S) # 工程文件路径 ARCHIVE_NAME=\"${APP_NAME}_${DATE}.xcarchive\" # 存放ipa的文件夹名称（根据自己的喜好自行修改） IPANAME=\"${IPA_NAME}_IPA\" # 要上传的ipa文件路径 ${username} 需要换成自己的用户名 ROOT_PATH=\"/Users/${username}/Desktop/Jenkins\" ARCHIVE_PATH=\"${ROOT_PATH}/Archive/${ARCHIVE_NAME}\" IPA_PATH=\"${ROOT_PATH}/Export/${IPANAME}\" echo \"-------------- ARCHIVE_PATH: ${ARCHIVE_PATH}\" echo \"-------------- IPA_PATH: ${IPA_PATH}\" # 导包方式(这里需要根据需要手动配置:AdHoc/AppStore/Enterprise/Development) EXPORT_METHOD=\"AdHoc\" # 导包方式配置文件路径(这里需要手动创建对应的XXXExportOptionsPlist.plist文件，并将文件复制到根目录下[我这里在源项目的根目录下又新建了ExportPlist文件夹专门放ExportPlist文件]) if test \"$EXPORT_METHOD\" = \"AdHoc\"; then EXPORT_METHOD_PLIST_PATH=${CODE_PATH}/ExportOptions.plist elif test \"$EXPORT_METHOD\" = \"AppStore\"; then EXPORT_METHOD_PLIST_PATH=${CODE_PATH}/ExportOptions/AppStoreExportOptios.plist elif test \"$EXPORT_METHOD\" = \"Enterprise\"; then EXPORT_METHOD_PLIST_PATH=${CODE_PATH}/ExportOptions/EnterpriseExportOptions.plist else EXPORT_METHOD_PLIST_PATH=${CODE_PATH}/ExportOptions/DevelopmentExportOptions.plist fi echo \"-------------- EXPORT_METHOD_PLIST_PATH: ${EXPORT_METHOD_PLIST_PATH}\" # 指ipa定输出文件夹,如果有删除后再创建，如果没有就直接创建 if test -d ${IPA_PATH}; then \"-------------- 删除:IPA Path : ${IPA_PATH}\" rm -rf ${IPA_PATH} mkdir ${IPA_PATH} \"-------------- 创建:IPA Path : ${IPA_PATH}\" else mkdir -pv ${IPA_PATH} \"-------------- 创建:IPA Path : ${IPA_PATH}\" fi # 进入工程源码根目录 cd \"${CODE_PATH}\" echo \"-------------- 安装Pod Code Path: ${CODE_PATH}\" # 执行pod pod install --verbose --no-repo-update #mkdir -p build # 清除工程 echo \"-------------- Clean项目 执行Shell: xcodebuild clean -workspace ${APP_NAME}.xcworkspace -scheme ${APP_NAME} -configuration ${configuration}\" xcodebuild clean -workspace ${APP_NAME}.xcworkspace -scheme ${APP_NAME} -configuration ${configuration} # 将app打包成xcarchive格式文件 echo \"-------------- archive项目 执行Shell: xcodebuild archive -workspace ${APP_NAME}.xcworkspace -scheme ${APP_NAME} -configuration ${configuration} -archivePath ${ARCHIVE_PATH}\" xcodebuild archive -workspace ${APP_NAME}.xcworkspace -scheme ${APP_NAME} -configuration ${configuration} -archivePath ${ARCHIVE_PATH} # 将xcarchive格式文件打包成ipa echo \"-------------- 导出ipa包 执行Shell: xcodebuild -exportArchive -archivePath ${ARCHIVE_PATH} -exportPath \"${IPA_PATH}\" -exportOptionsPlist ${EXPORT_METHOD_PLIST_PATH} -allowProvisioningUpdates\" xcodebuild -exportArchive -archivePath ${ARCHIVE_PATH} -exportPath \"${IPA_PATH}\" -exportOptionsPlist ${EXPORT_METHOD_PLIST_PATH} -allowProvisioningUpdates # 删除工程文件 # echo \"+++++++++删除工程文件+++++++++\" # rm -rf $ARCHIVE_PATH Fastlane工具 Jenkins自动化工具 var className='atoc';"},"Program/iOS/Others/iOS输入框一些问题.html":{"url":"Program/iOS/Others/iOS输入框一些问题.html","title":"iOS输入框一些问题","keywords":"","body":"iOS输入框总结 限制输入框输入字数 对于 iOS 系统自带的键盘，有时候它在输入框中填入的是占位字符（已被高亮选中起来），等用户选中键盘上的候选词时，再替换为真正输入的字符 比如输入框限定最多只能输入 10 位，当已经输入 9 个汉字的时候，使用系统拼音键盘则第 10 个字的拼音就打不了（因为剩余的 1 位无法输入完整的拼音）。 输入框中的拼音会被高亮选中起来，所以我们可以根据 UITextField 的 markedTextRange 属性判断是否存在高亮字符，如果有则不进行字数统计和字符串截断操作。我们通过监听 UIControlEventEditingChanged 事件来对输入框内容的变化进行相应处理，如下： [self.textField addTarget:self action:@selector(textFieldDidChange:) forControlEvents:UIControlEventEditingChanged]; - (void)textFieldDidChange:(UITextField *)textField { // 判断是否存在高亮字符，如果有，则不进行字数统计和字符串截断 UITextRange *selectedRange = textField.markedTextRange; UITextPosition *position = [textField positionFromPosition:selectedRange.start offset:0]; if (position) { return; } // maxWowdLimit 为 0，不限制字数 if (self.maxWowdLimit == 0) { return; } // 判断是否超过最大字数限制，如果超过就截断 if (textField.text.length > self.maxWowdLimit) { textField.text = [textField.text substringToIndex:self.maxWowdLimit]; } // 剩余字数显示 UI 更新 } 常用的UI属性 textField.attributedPlaceholder = [[NSAttributedString alloc] initWithString:@\"请填写\" attributes:@{NSFontAttributeName : SystemFont(14), NSForegroundColorAttributeName : UIColorFromRGB(0x999999, 1.0)}]; var className='atoc';"},"Program/iOS/Others/iOS文件及持久化.html":{"url":"Program/iOS/Others/iOS文件及持久化.html","title":"iOS文件及持久化","keywords":"","body":"iOS文件及持久化 iOS 文件目录 在iOS系统的安全机制，每个APP都有自己的文件目录，且只能访问自己的文件目录。该机制被称为沙盒机制。 苹果官方文件系统编程指南--官网 沙盒文件结构如下： bundle container目录为APP程序的安装目录，在安装后为不可修改状态 data container目录为APP数据存储目录，保存APP运行时需要的数据 iCloud container目录为云存储目录，当APP需要iCloud云存储时可以进行访问 data container目录 Documents 保存用户创建的文档文件的目录，用户可以通过文件分享分享该目录下的文件。在iTunes和iCloud备份时会备份该目录。建议保存你希望用户看得见的文件。 Library 苹果不建议在该目录下保存任何用户相关数据，而是保存APP运行需要的修改数据，当然用户可以根据自己的实际需要进行保存。 Cache 建议保存数据缓存使用。在用户的磁盘空间已经使用完毕时有可能删除该目录下的文件，在APP使用期间不会删除，APP没有运行时系统有可能进行删除。需要持久化的数据建议不要保存在该目录下，以免系统强制删除。 Preferences 用户偏好存储目录，在使用NSUserDefaults或者CFPreferences接口保存的数据保存在该目录下，编程人员不需要对该目录进行管理。在iTunes和iCloud备份时会备份该目录。 tmp 苹果建议该目录用来保存临时使用的数据，编程人员应该在数据长时间内不使用时主动删除该目录下的文件，在APP没有运行期间，系统可能删除该目录下的文件。在iTunes和iCloud备份时不会备份该目录。 代码获取目录路径 //沙盒根目录 NSString *homePath = NSHomeDirectory(); //document目录 NSString *documentPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject; //library目录 NSString *libraryPath = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES).firstObject; //caches目录 NSString *cachesPath = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES).firstObject; //application support目录 NSString *applicationSupportPath = NSSearchPathForDirectoriesInDomains(NSApplicationSupportDirectory, NSUserDomainMask, YES).firstObject; //preference目录 NSString *preferencePath = NSSearchPathForDirectoriesInDomains(NSPreferencePanesDirectory, NSUserDomainMask, YES).firstObject; //tem目录 NSString *temPath = NSTemporaryDirectory(); 持久化存储方式 Plist，只存储数组、字典，但是数组和字典里不能有自定义对象。 偏好设置，也不能存储自定义对象。 归档NSCoding， 存储自定义对象。 SQLite3 操作数据比较快 可以局部读取 比较小型，占用的内存资源比较少 Core Data Realm 移动数据库 Plist 如果对是NSString、NSDictionary、NSArray、NSData、NSNumber等类型，就可以使用writeToFile:atomically:方法直接将对象写到属性列表文件中, plist是一种XML格式的文件 归档NSDictionary: 将一个NSDictionary对象归档到一个plist属性列表中 // 将数据封装成字典 NSMutableDictionary *dict = [NSMutableDictionary dictionary]; [dict setObject:@\"张三\" forKey:@\"name\"]; [dict setObject:@\"155xxxxxxx\" forKey:@\"phone\"]; [dict setObject:@\"27\" forKey:@\"age\"]; // 将字典持久化到Documents/stu.plist文件中 [dict writeToFile:path atomically:YES]; 恢复NSDictionary: 读取plist，恢复NSDictionary对象 // 读取Documents/stu.plist的内容，实例化 NSDictionaryNSDictionary *dict = [NSDictionary dictionaryWithContentsOfFile:path]; NSLog(@\"name:%@\", [dict objectForKey:@\"name\"]); NSLog(@\"phone:%@\", [dict objectForKey:@\"phone\"]); NSLog(@\"age:%@\", [dict objectForKey:@\"age\"]); 偏好设置 iOS提供了一套标准的解决方案来为应用加入偏好设置功能。 每个应用都有个NSUserDefaults实例，通过它来存取偏好设置。 比如，保存用户名等： NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults]; [defaults setObject:@\"张三\" forKey:@\"username\"]; [defaults setFloat:18.0f forKey:@\"userAge\"]; 读取保存的设置: NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults]; NSString *username = [defaults stringForKey:@\"username\"]; float userAge = [defaults floatForKey:@\"userAge\"]; 注意： UserDefaults设置数据时，不是立即写入，而是根据时间戳定时地把缓存中的数据写入本地磁盘。所以调用了set方法之后数据有可能还没有写入磁盘应用程序就终止了。出现以上问题，可以通过调用synchornize方法[defaults synchornize]; 强制写入 归档(NSKeyedArchiver) 如果对象是 NSString、NSDictionary、NSArray、NSData、NSNumber等类型，可以直接用NSKeyedArchiver进行归档和恢复 不是所有的对象都可以直接用这种方法进行归档，只有遵守了NSCoding协议的对象才可以。 NSCoding 协议有2个方法： encodeWithCoder: 每次归档对象时，都会调用这个方法。一般在这个方法里面指定如何归档对象中的每个实例变量，可以使用encodeObject:forKey:方法归档实例变量。 initWithCoder: 每次从文件中恢复(解码)对象时，都会调用这个方法。一般在这个方法里面指定如何解码文件中的数据为对象的实例变量，可以使用decodeObject:forKey方法解码实例变量。 归档数组等Cocoa Object NSArray *array = [NSArray arrayWithObjects:@”a”,@”b”,nil]; [NSKeyedArchiver archiveRootObject:array toFile:path]; 归档自定义对象：UserModel 实现 NSCoding： @interface UserModel : NSObject @property (nonatomic, copy) NSString *name; @property (nonatomic, assign) NSInteger age; @end @implementation UserModel #pragma mark - NSCoding - (instancetype)initWithCoder:(NSCoder *)aDecoder { self = [super init]; if (self) { self.name = [aDecoder decodeObjectForKey:@\"name\"]; self.age = [aDecoder decodeIntegerForKey:@\"age\"]; } return self; } - (void)encodeWithCoder:(NSCoder *)aCoder { [super encodeWithCode: aCoder]; [aCoder encodeObject:self.name forKey:@\"name\"]; [aCoder encodeInteger:self.age forKey:@\"age\"]; } @end 归档方法 [NSKeyedArchiver archiveRootObject:person toFile:path]; 解档方法 UserModel *userModel = [NSKeyedUnarchiver unarchiveObjectWithFile:path]; SQLite3 SQLite 是一款嵌入式的轻量关系型文件数据库。 它占用资源非常的低，在嵌入式设备中，可能只需要几百K的内存就够了。 它的处理速度比 Mysql、PostgreSQL 这两款著名的数据库都还快。 数据库存储数据的步骤 创建数据库(DB) 新建一张表（table）。 添加多个字段（column，列，属性）。 添加多行记录（row，每行存放多个字段对应的值）。 推荐使用FMDB， FMDB以OC的方式封装了SQLite的C语言API 常用的SQL语句 创建表 create table t_student (id integer, name text, age inetger, score real); create table if not exists Student ( ID integer primary key autoincrement, Name varchar(128), Age integer, Class interger default 0, RegisterTime datetime, Money float default 0, Birthday date ); 删除表 /// 删表: drop table 表名; drop table if exists 表名; drop table t_student; 插入数据（insert） /// 插入数据: insert into 表名 (字段1, 字段2, …) values (字段1的值, 字段2的值, …); insert into t_student (name, age) values (‘张三’, 10); 更新数据（update） /// update 表名 set 字段1 = 字段1的值, 字段2 = 字段2的值, … ; update t_student set name = ‘jack’, age = 20; 删除数据（delete） ///delete from 表名; // 删除指定ID值为2的记录 delete from t_student where ID=2; // 删除t_student表中所有的记录(慎重) delete from t_student; 查询数据（select） /// select 字段1, 字段2, … from 表名; select * from 表名; select name, age from t_student ; select * from t_student ; // 条件查询 select * from t_student where age > 10 ; // 模糊查询 select * from t_student where name like '%张%' or phone like '%张%'; Realm Realm 移动数据库是一种新型的移动数据库，它是全新的, Realm 移动数据库因此 和 SQLite 没有任何关系 也不是另外一个 SQL 数据库；它的目标就是去解决这些领域里面的已知问题。但是 Realm 移动数据库也 不是一个键-值存储 类型，这种存储类型在某些情况下非常棒，但是开发者真的很想直接和本地对象打交道。 Realm 移动数据库 也不是一个 ORM。ORM 把 SQL 数据库的表结构中平的数据转换成了对象图，这样它们能被本地代码使用了。 Realm 的客制化存储引擎不需要把数据转换成对象图，所以它不需要 ORM Realm 数据库 直接存储对象 在磁盘上，当然需要最少的类型和结构的转换。英文它没有映射关系或者其它动态解读实体，Realm 移动数据库能够从内存到磁盘非常迅速地操作对象。 Realm官网 var className='atoc';"},"Program/iOS/Others/cell事件和didSelect冲突.html":{"url":"Program/iOS/Others/cell事件和didSelect冲突.html","title":"cell事件和didSelect冲突","keywords":"","body":"cell事件和didSelect方法冲突 我们有时候在Cell上添加了手势，发现不响应对应的事件， debug的时候发现没有走对应的事件方法，却走了cell的didSelect方法，用以下代码可以处理 实现UIGestureRecognizerDelegate的代理方法 public func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldReceive touch: UITouch) -> Bool { let touchClass = NSStringFromClass((touch.view?.classForCoder)!) let supClass = NSStringFromClass((touch.view?.superview?.classForCoder)!) if touchClass == \"UITableView\" || touchClass == \"UICollectionView\" || supClass == \"UITableView\" || supClass == \"UICollectionView\" || touchClass == \"UITableViewCellContentView\" || supClass == \"UITableViewCell\" { return false } let touchPoint = touch.location(in: contentView) if contentView.layer.contains(touchPoint) { return false } return true } } - (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch{ NSString *touchClassName = NSStringFromClass([touch.view class]); // 若为UITableViewCellContentView（即点击了tableViewCell）， if ([touchClassName isEqualToString:@\"UITableViewCellContentView\"] || [touchClassName isEqualToString:@\"UICollectionView\"] || [touchClassName isEqualToString:@\"UITableView\"]) { // cell 不需要响应 父视图的手势，保证didselect 可以正常 return NO; } //默认都需要响应 return YES; } var className='atoc';"},"Notes/git/git设置代理.html":{"url":"Notes/git/git设置代理.html","title":"git设置代理","keywords":"","body":"Git设置和取消代理 常见场景 我们在访问github或者提交代码到github时，经常会遇到\"unable to access ': Failed to connect to github.com port 443: Operation timed out\" 的错误 配置文件 在git的配置文件中添加代理， 配置文件路径： ~/.gitconfig 查看Git配置 git config --list 编辑配置命令 sudo vim ~/.gitconfig git config --global --edit 使用钥匙串凭据 git config --global credential.helper osxkeychain 直接修改代理 直接修改用户主目录下的 .gitconfig 文件 执行vim ~/.gitconfig 以下的1080是电脑的代理端口，请根据实际端口填写 socks5代理 [http] proxy = socks5://127.0.0.1:1080 [https] proxy = socks5://127.0.0.1:1080 普通代理 [http] proxy = http://127.0.0.1:1080 [https] proxy = http://127.0.0.1:1080 命令设置 设置全局代理 //http git config --global https.proxy http://127.0.0.1:1080 //https git config --global https.proxy https://127.0.0.1:1080 设置Socks5代理 //使用socks5代理的 例如ss，ssr 1080是windows下ss的默认代理端口,mac下不同，或者有自定义的，根据自己的改 git config --global http.proxy socks5://127.0.0.1:1080 git config --global https.proxy socks5://127.0.0.1:1080 只对github.com使用代理，其他仓库不走代理 git config --global http.https://github.com.proxy socks5://127.0.0.1:1080 git config --global https.https://github.com.proxy socks5://127.0.0.1:1080 git config --global http.https://github.com.proxy http://127.0.0.1:1080 也可以这么写 [http \"https://github.com\"] proxy = http://127.0.0.1:1080 取消github代理 git config --global --unset http.https://github.com.proxy git config --global --unset https.https://github.com.proxy 取消全局代理 git config --global --unset http.proxy git config --global --unset https.proxy var className='atoc';"},"Notes/git/github打不开打开太慢.html":{"url":"Notes/git/github打不开打开太慢.html","title":"github打不开打开太慢","keywords":"","body":"github打不开打开太慢 为什么访问速度会很慢 GitHub的CDN域名遭到DNS污染， 最主要的原因是GitHub的分发加速网络的域名遭到DNS污染。 由于GitHub的加速分发CDN域名assets-cdn.github.com遭到DNS污染，导致无法连接使用GitHub的加速分发服务器，才使得访问速度很慢。 如何解决DNS污染 一般的DNS问题都可以通过修改Hosts文件来解决，GitHub的CDN域名被污染问题也不例外，同样可以通过修改Hosts文件解决。 将域名解析直接指向IP地址来绕过DNS的解析，以此解决污染问题。 查找github的IP地址 先使用工具查询GitHub的DNS的IP 点击查询IP地址 获取TTL值最小的IP地址 修改Hosts文件 修改hosts， 增加github相关的IP映射 hosts文件路径: /private/etc/hosts 编辑命令 sudo vim /private/etc/hosts 在文件的尾部添加对应的映射 140.82.113.3 github.com 192.30.253.118 gist.github.com 185.199.109.153 assets-cdn.github.com 199.232.68.133 raw.githubusercontent.com 199.232.68.133 gist.githubusercontent.com 199.232.68.133 cloud.githubusercontent.com 199.232.68.133 camo.githubusercontent.com 199.232.28.133 avatars0.githubusercontent.com 199.232.28.133 avatars1.githubusercontent.com 199.232.28.133 avatars2.githubusercontent.com 199.232.28.133 avatars3.githubusercontent.com 199.232.28.133 avatars4.githubusercontent.com 199.232.28.133 avatars5.githubusercontent.com 199.232.28.133 avatars6.githubusercontent.com 199.232.28.133 avatars7.githubusercontent.com 199.232.28.133 avatars8.githubusercontent.com 刷新DNS 域名更换了一个新的 IP 地址，但是使用电脑访问的话并不会立即生效，这个时候只需要强制的刷新一下本地的 DNS 缓存，就可以拿到我们最新设置的 域名-IP 映射关系，进行域名的访问 sudo killall -HUP mDNSResponder var className='atoc';"},"Notes/git/git命令.html":{"url":"Notes/git/git命令.html","title":"git命令","keywords":"","body":"git相关总结 git命令 基本操作 # 初始化本地git仓库（创建新仓库） git init # 配置用户名 git config --global user.name \"xxx\" # 配置邮件 git config --global user.email \"xxx@xxx.com\" # 查看当前版本状态（是否修改） git status # 增加当前子目录下所有更改过的文件至index git add . # 提交 git commit -m 'xx' # 将当前分支push到远程master分支 git push origin master # 获取远程分支master并merge到当前分支 git pull origin master 分支操作 # 显示本地分支 git branch # 显示所有分支 git branch -a var className='atoc';"},"Notes/git/gitbook使用.html":{"url":"Notes/git/gitbook使用.html","title":"gitbook使用","keywords":"","body":"gitbook使用 初始化 在使用 gitbook init 之后本地会生成两个文件 README.md 和 SUMMARY.md ，这两个文件都是必须的，一个为介绍，一个为目录结构。 插件 book.json 文件是Gitbook的配置文件 我们更新了book.json文件后需要执行 gitbook install安装插件 本地预览 当内容书写完毕后，可以在终端中输入如下命令，实现实时预览 gitbook serve gitbook serve ./ {book_name} gitbook serve 命令实际会先调用 gitbook build 编译书籍，完成后打开 web 服务器，默认监听本地 4000 端口，在浏览器打开 http://localhost:4000 即可浏览电子书。 发布到Github Pages 修改书籍发布需要先构建，然后上传到github gitbook build ./ docs git add --all git commit -m \"some update\" git push -u origin master var className='atoc';"},"Finance/":{"url":"Finance/","title":"简介","keywords":"","body":"金融笔记 总结一些投资方面的笔记 投资笔记 霍华德马克思 施洛斯 黄奇帆 查理芒格 彼得林奇 邱国鹭 戴维斯 巴菲特 格雷厄姆 曼昆 财务笔记 A股财报披露知识 财报入门 财报思维导图 利润表 资产负债表 现金流量表 财报被操纵的痕迹 财报被操纵的手法 ROE-ROA-ROIC 复利 公司估值法 重资产和轻资产 行业知识 地产 var className='atoc';"},"Finance/Notes/霍华德马克思.html":{"url":"Finance/Notes/霍华德马克思.html","title":"霍华德马克思","keywords":"","body":"霍华德马克思 笔记 《投资最重要的事》 作者霍华德·马克斯，橡树资本联席董事长及创始人， 读完后记录下笔记 学会第二思维 第二层次思维是深邃复杂而迂回的 要考虑的东西有： 未来可能出现的结果会在什么范围之内 我认为会出现什么样的结果 我正确的概率有多大 人们的共识是什么 我的预期与人们的共识有多大差异 资产的当前价格与大众所认为的未来价格以及我所未来价格相符的程度如何 价格中所反映的共识心理是过于乐观还是过于悲观 如果大众的看法是正确的资产价格将会发生什么样的变化？如果我的是正确的资产价格又会怎样？ 如果你的行为是常规性的你很可能就会得到常规性的结果 -无论好坏 只有当你的行为是非常规性的时,你的表现才有可能是非常规性的, 而只有当你的判断高人一等时, 你的表现才会高于平均表现 理解市场的有效性和局限性 有效的含义应该是指迅速快捷地整合信息而不是正确 没有一个市场是完全有效或者无效的它只是一个程度问题有效性并没有普遍到我们该放弃良好业绩的程度 出于对有效性的尊重在采取行动之前 我们应该询问几个问题： 在成千上万投资者时刻准备着抬高任何过于低廉的价格时为什么还有可能存在便宜货？ 如果相对于风险来说收益显得很高 有没有可能是你忽略了某些隐性风险？ 为什么资产卖家愿意以能让你获得超额回报的价格卖出资产？你是否真的比卖家知道得更多？如果这是一笔杰出的交易为什么其他人不一哄而上？ 正确评估价值 最佳选择就是基本面所反映出来的内在价对内在价值的准确估计是进行稳定冷静有利可图的投资的根本基础 在下跌时持有并继续以更低价格买进股票是相当困难的事在损失面前人人都会不安 在一个下跌市场中获利有三个因素： 一是必须了解内在价值 二是必须足够自信坚持地持股并不断买进即使价格已经跌到似乎在暗示你做错了的时候 三是估值必须是正确的 价值投资者想念当前价值高于当前价格从而买进股票（即使它们的内在价值显示未来的增长有限） 成长型投资者相信未来价值的迅速增长足以导致价格大幅上涨从而买进股票（即使它们的当前价值低于当前价格） 如果判断正确成长型投资者的上涨潜力更富戏剧性而价值投资的上涨潜力更具有持续性我选择的是价值投资法持续性比戏剧性更重要 价格与价值的关系 价值与价格在没有比崩盘时从不顾价格必须卖出的人手中买进更好的事了 既然从强制卖家手中买进是世界上最美妙的事那么成为强制卖家就是最悲惨的事所以把自己的事情安排好保证自己能够在最艰难的时期坚持住是非常重要的要做好这一点既需要有长期资本又需要强大的心理素质 确定价值的关键是熟练的财务分析而理解价格价值关系及其前景的关键则主要依赖对其他投资者思维的洞察投资者心理几乎可以导致证券在短期内出现任何定价而无论基本面如何 投资是一场人气竞赛在人气最旺的时候买进是最危险的在那个时候一切利好因素和观点都已经被计入价格中而且再也不会有新的买家出现 最安全获利潜力最大的投资是在没有喜欢的时候买进假以时日一旦证券受到欢迎那么它的价格只可能向一个方向变化：上涨 基本面价值只是决定证券价格的因素之一还要设法让心理和技术为我所用 低价买进可能会出现错误估计了当前价值或者会出现降低价值的事件或者市场的冷淡导致价格更低或者价格与内在价值达到一致所需要的时间比你可以等待的时间要长但是低于价值买进并非万无一失但却是我们最好的机会 理解风险 靠更高风险的投资来获得更高的收益是绝对不可能的原因何在？很简单：如果更高风险的投资确实能够可靠地产生更高的收益那么它就不是真的高风险了，正确的表述是：为了吸引资本风险更高的投资必须提供更地的收益前景，更高的预期收益 但绝不表示这些更高的预期收益必须实现 当定价公平时风险较高的投资意味着：更高的预期收益 获得较低收益的 可能在某些情况下损失的可能 传统的风险—收益曲线图具有误导性它虽然表现了风险与收益的正相关关系, 却没有表现出其中所涉及的不确定性,它对承担更高的风险便能赚更多钱的坚定暗示, 已经给许多人造成了极大的痛苦 在以低于价值买进证券的时候高收益低风险是可以同时实现的同样价格过高则意味着低收益高风险 单调的被忽视的可能遭到冷落和打压而成为低价的股票以低波动性低基本面风险以及在市场不利时损失更低为特征在大多数情况下这类低价证券最大的风险是在牛市中表现落后的可能性不过具有风险意识的价值投资者是愿意承担这种风险的 识别风险 洞察价格与价值之间的关系无论对单个股票还是整体市场都是成功应对风险的重要组成部分 普遍想念没有风险本身就是最大的风险因为只有当投资者适当规避风险时预期收益中才会包含风险溢价 在市场的钟摆达到最高点时认为风险很低以及投资一定能获利的信念令人群激动不已以致他们丧失了对损失应有的警惕担忧及恐惧只对错失机会的风险耿耿于怀 不断提高的自信应带来更多的担忧正像不断增加的恐惧和风险规避共同在降低风险时增加风险溢价一样这叫风险的反常性 “任何价钱我都不会买进所有人都知道风险太大了”在生活中我听到过很多这样的话而它已经为我提供过最好的投资机会 我坚信最大的投资风险存在于最不容易被察觉的地方反之亦然： 在所有人都想念某种东西有风险的时候他们不愿购买的意愿通常会把价格降低到完全没有风险的地步广泛的否定意见可以将风险最小化因为价格里所有的乐观因素都被消除了当人人都相信某种东西没有风险的时候, 价格通常会被哄抬至蕴含巨大风险的地步,这可能会使人们推崇的最好资产成为风险最高的资产, 存在这一矛盾的原因是大多数投资者认为风险与否的决定因素是质量而不是价格, 但是高质量资产也可能是有风险的,低质量资产也可能是安全的, 所谓的质量不过是为资产所付出的价格问题, 因此狂热的公众意见不仅是潜在低收益的源泉还是高风险的源泉 控制风险 杰出投资者之所以杰出 是因为他们拥有与创造收益的能力同样杰出的风险控制能力 重要的是要意识到 即使没有发生损失 风险也是可能存在的 因此没有损失并不一定意味着投资组合是安全的 风险控制在繁荣期是观察不到的 但依然是必不可少的 优秀的投资者获得的收益可能不比别人高 但在实现同等收益或者稍低收益的前提下承担了较低风险 投资者的工作是以盈利为目的聪明地承担风险 风险控制不等于风险规避风险规避很有可能会连同收益一起规避 贯穿长期投资成功之路的是风险控制而不是冒进在整个投资生涯中 大多数投资者取得的结果将更多地取决于致败投资的数量及程度而不是制胜投资的伟大良好的风险控制是优秀投资者的标志 关注周期 价值可以消失 预测可能出错有把握的事情可能失败不过无论如何我们有信心把握住的概念有二： 法则一：多数事物都是周期性的 法则二：当别人忘记法则一时 世界具有周期性的根本原因是人类的参与 机械化的东西可以直线运行但历史经济领域涉及到人的人是情绪化并且善变的缺乏稳定性和客观性结果就有了可变性和周期性 周期是自我修正的周期的逆转不一定依赖外源性事件周期的发展趋势本身就是造成周期逆转的原因 因此我喜欢一句话：祸兮福所倚 福兮祸所伏 特别是信贷周期它具有必然性极端波动性, 也具有为适应它的投资者创造机会的能力, 在所有周期中信贷周期是我最喜欢的过程很简单：经济进入繁荣期资金提供者增加坏账极少风险规避消失金融机构扩大业务提供更多资本通过降息放宽信贷标准争夺市场，当达到资本提供者开始为不具备资格的借款人和项目提供资本时，开始出现逆转损失导致借款人回避风险规避增加利率信贷限制提高可得资本减少， 企业迫切需要资本借款人无法展期债务导致债务违约企业破产这一过程导致加剧经济萎缩这一过程达到极点时因为贷款或者资的竞争较低高收益和高信誉成为可能将再次发生逆转 当你面对一个“周期已经中断”为基础建立的交易时记住它永远是一个失败的赌注 var className='atoc';"},"Finance/Notes/施洛斯.html":{"url":"Finance/Notes/施洛斯.html","title":"施洛斯","keywords":"","body":"施洛斯投资笔记 基本原则： 逆向投资。买入因各种原因遭到人们抛弃，受到打压的公司，只要情况稍有好转，在杠杆效应作用下就能赚很多。 不跟随大众。所有人都想抓住正确的时机，大家都玩的游戏，我就不跟着掺和。如果你买的是价值，可能会买得太早，要是跌到更低了，就继续买入，必须对自己做的事有信心。 指导思想：不亏钱. 有限投资于成长。我现在看股票的指导思想就是不亏钱。这种理念有一个问题，对盈利能力不够重视。当股票上涨到我们认为合理的价格后，我们就会卖出，因为在我们的投资组合中对成长的投资是有限的。 严格遵守原则。实现成功投资的最佳途径就是制定一些原则，制定一些只要严格遵循就会减少亏损几率的原则，并严格遵守这些原则。 对宏观经济的看法： 不预测。有些人能预测出来，但大数多人是不行的，也不要尝试预测宏观经济和牛熊市。 不追涨. 不追热点。要是市场涨疯了，你还想留在市场里，要么降低标准，要么买入不会参与到疯狂中的股票。因为它们不是当前的市场热捧的，在这种情况下，你可能会错过行情，因为你没有追涨，没有买大家追捧的热门股。但当市场下跌时，你买的股票可能也不会跌太多。 不关注大宗商品走势。我对大宗商品毫不所知，不知道它们的价格走向。我买入开采铜矿的大宗商品公司，只是根据股价看觉得便宜，不是因为我知道铜价或白银的价格走向。 分散投资： 喜欢分散投资。我们差不多有100家公司。我喜欢拥有多支股票，巴菲特喜欢拥有几只股票，他是巴菲特，这么做没有错。但如果你不是，你必须选择适合自己的方式，就我而言，我喜欢晚上睡得安稳。分散是对不确定性的保护。 注意总体仓位控制。我们常犯的错误是开始的时候太激进，一开始买得太多，股价跌到更低时，要投入大量资 金才能把成本摊下来。有时候，我们开始买的实在太多了，股价跌到更低，这时再加仓就会导致过于集中。 每只股票分批买入的仓位。发现值得买入的股票时，首先要知道我们不知道股价会跌到多少。我觉得如果真是非常看好的机会，第一次买入时可能最少要投入这只股票计划仓位的50%，有时候我觉得最好是70%。谁都不知道下面会怎么样，股票可能一下子就涨起来。有时候，我们觉得股票不是太便宜，不过会先买一点，先进到里面去，可能只买计划仓位的10%。 （说明：2和3点并不矛盾，2是讲总体仓位的控制，即要控制好每只股票在总体仓位中的比重，严格避免某只股票仓位过重的情况。3是讲每一只股票在买入是可以买入的仓位。以施4500万元总资金. 100只持有股票来说，平均每只股票占比为1%，即45万元。但他后面也说真正看好的股票，可能占到10-15%，也就是450万到700万。对我们小资金量而言，要持有100只股票. 每只股票1%资金分配太少，如果要分散投资，还是在30只股票为宜，也就是每只股票占比为3%左右。） 最高单股仓位。我们要是真看好了，会投入投资组合高达10%-15%的仓位。 换手率。我们的平均换手率为每年25%，也就是持股时间一般为3-4年。 不赞同卖A换B。一只股票一步步渐入佳境，你也慢慢熟悉这只股票，要是因为相对价值换股，在新买入的股票上还要熬三年。这些东西都有生命周期。所以说，我们不愿意用A股票换B股票。 行业同样应分散。不会在投资组合中只投资一两个行业，但在发现冷门行业中有很多便宜的股票时，会加大对这些股票的投资力度。 行业和企业选择 以股权投资思维看待股票。不要只看净资产，要研究一下公司的基本情况，觉得公司可以卖多少钱。就算公司没有出售的打算，也可以这么看，问自己花钱买入公司值不值？如果觉得价格合格就会投资。 购买坏行业中的好公司。我们更愿意买入的，不能说是“重工业”的股票，但可以说是所在行业陷入困境的股票。如我们买入的克利夫兰公司有股票，它的主要业务是向钢铁厂销售铁矿石。我们买入这只股票，不是因为我们在钢铁行业寻找便宜的公司，而是因为觉得它物有所值。它做的不是好生意，它是烂行业里的好公司 。 克服对坏行业的恐惧。有时候人们对一个行业太恐惧，不敢买入便宜的股票。 不愿意购买的行业。我不购买房地产公司的股票。我们也不愿意买入蒸蒸日上行业的股票，我也不愿意买入电脑等行业的股票。我不愿意出那么高的价格买入食品股。我不是很看好银行股，我还是对实打实制造产品的公司更放心。 喜欢买制造业公司，如生产鞋. 汽车的公司，不喜欢电视广播公司。只要公司制造的产品没太大问题，我就愿意买。和服务业相比，我更喜欢制造业。 不为有经济特权的企业给予过高出资 。巴菲物喜欢有经济特权的企业，喜欢好生意。我们也喜欢，不过我们不愿意花那么多钱买，所以我们就不买。我们买的是难做的生意。他喜欢搭顺风车，我们愿意逆水行舟。 不为未来价值出资。在的情况是所有人都追求有经济特权的企业。在我看来，成功投资的关键是比较价值和当前的价格。许多投资人不用现在的价值，而是用将来的价值和当前的价格比较。我没这个能力，别人如何做不我管，我还是按我们的老一套来。 预测公司未来的难度。我们的投资方法是比较股票的市场价格和我们的估值，我们买股票不预测它将来会如何，我们在预测方面不是很在行。要预测公司的未来，你需要对公司了解得非常透彻，需要调研竞争对手. 供应商，我们不想这么做，我们研究数字。 最重要的是价格，就算公司 是好公司，如果价格高得离谱， 也不值得买。 寻找下跌股票。股票能够引起施洛斯的关注一般是价格下跌了。他们仔细查看创新低的股票列表，寻找下跌的股票。如果发现股票创了两年或三年新低，那就更好了。 自下而上后再横向比较。他们也不是完全被动的，按照自下而上的方式找到便宜的股票，在少量买入之后，他们会横向比较行业中的其他公司 ，这些公司 也便宜吗？便宜的原因一样吗？他们可能找到一家比开始买入公司 更便宜. 质量更好. 利润率更高或负债率更低。如果这样，只要仍能从行业的低迷中获利，他们会换成更好的。 喜欢公司的快照。我喜欢买①资本结构简单的公司，②它们的债务不高，③管理层持有相当份额的股票，而且④公司也有很长的历史。 持有少量股票可以有利于更用心了解企业。只有买入以后才能全面了解一只股票。买入之前是以旁观者的身份看股票，不会太上心。买入之后就不一样了，原来没有发现的缺点都看得很清楚。当然了，持有一段时间，也会发现开始没有看出来的机会。 存货的实际价值占账面价值的50%以上。大家怎么评估存货？账面价值的50%？可能不止这些，一般来说，存货不如现金应收账款，这我们知道，但是可能也没有一些人想得那么坏。 不要因为折旧而迷惑了对盈利能力的判断。假设有两家工厂，一家是40年前建的，一家是新的，两个工厂都记录在报表上。但新工厂的盈利能力可能要比旧工厂高得多。可是旧工厂不用折旧，低折旧可能有些夸大了它的盈利能力。 市盈率高低与是否买入没有直接因果关系。只看市盈率低就买入股票而遭到亏损的人不在少数，我们买的股票可能是市盈率低的，也可能是市盈率高的。 不深研究企业生意。我不深入研究公司的生意好不好，是因为我觉得做不来。我们买股票的这种风格，因为有资产保护，不必对生意很精通。 了解公司全貌。除了资产负债表，还必须对一家公司有个大概的感觉，它的历史. 背景. 股东. 过去的行为. 生意. 分红. 未来的盈利状况等。必须要对公司有个整体的感觉。 买入陷入困境的公司，我的客户就不喜欢陷入困境的公司。我们的行为是逆人性而动，而且我们在下跌过程中还会继续买入。 对公司盈利的看法： 盈利是不稳定的。在市盈率不变的情况下，公司下一年或下一季度的盈利变化都可能对股价造成很大影响。 没有预测盈利的能力。很难具有巴菲特一样分析预测公司盈利的能力。 市场给的市盈率会发生变化。即使预测得很准，别人给的市盈率会发生改变。一家公司 因为每股盈利是31分，没有达到35分的预期，股价在一天之内就从25元跌到20元，看到这种情况，我总是觉得好笑。 盈利可以被操纵。盈利可以被合理合法地操纵，如果人们只看盈利，他们的认识可能会被扭曲。 买入标准： 以净资产为主要因素的购入标准。从根本上说，我们追求的是下跌保护。股价为10元，每股净资产有15元，这样的股票很安全。以净资产作为衡量标准，可以回避下跌风险，不至于遭受太大的损失。我们过去寻找股价为净资产一半的公司，要是没有，我们就找股价是净资产三分之二的。现在我们找的是股价等于净资产的。不过除非是特殊情况 或者有经济特权，我们几乎不会以高于资 产价值的价格买入股票。 不得超过两倍市净率。不管什么股票，我们都不会以两倍市净率买入，这是我们的原则，我们绝对不会违反。 安全边际。我觉得安全边际就是净资产远高于市场价格。 要有盈利能力。我们也喜欢买入有投票有盈利能力。 换手股不超过20%。有些股票一个月的换手率是20%，我们对交易量大. 波动性强的股票避而远之。 买入时要考虑公司市值大小。股民最愚蠢的错误就是把一股的股价和整个公司 的市值等同起来。他们想不到如果一家公司有1亿股流通股，股价为1元，公司市值就是1亿元。另一家公司只有10万股流通股，股价是20元，它的市值只有200万元。许多人只看股价，觉得第一家公司比第二家公司便宜。 不买小市值公司。（也就是我们的创业板？）我们也不能买入大量小市值的股票。从我们的经验来看，最好不要买太多有价无市的股票，因为可能套在里面，行情不好的时候根本卖不出去。 不买以收购扩张的大公司。我们不愿意玩收购游戏，所以一般不买大公司，进行收购的一般都是大公司。 股价处于历史低位。买的时候，我发现最好买在过去几年的低点附近。一只股票从125的高点跌到60，你可能就动心了。可3年前它的股价是20，这说明股价现在还是有些脆弱。 公司至少要有20年以上的历史。即使公司可能和多年以有所不同。年报中我会看业绩历史，如果公司成立没多久，我可能不会买入，因为不好评估。如果公司经营了二三十年，就可以了解它的长期业绩，然后再看资 产负债表。 公司不能有太多的债务。 卖出标准： 就算格雷厄姆在21元买入了施乐公司，我可以保证他会在50元卖出，根本不理会它以后能涨到2000元。 卖出的时候不要太急。如果股票达到你认为合理的价格，你可以卖出，但是许多时候只是因为股票涨了50%，人们就说卖掉锁定利润。卖出之前，重新评估公司，比较价格与净资 产价值。要注意股市的估值水平：是不是股息率较低. 市盈率较高？股市是否处理历史高位？人们是否非常乐观？ 如果我们买入价格是20元，过去这只股票曾涨到40. 50元，当它回到40. 50元时，我们就觉得它回到了历史价格。如是我们认识仍然是低估的，就继续拿着。我们经常卖早了。卖出东西的时候，总得让别人有利可图，这样别人才会买。要是你非得等到股价高估了，就有风险了，这时候可能没有人愿意买了，可能再次下跌。 有可能的话，我觉得一只股票最好能赚50%的利润，问题是一只股票30买入的，涨到了50，如果是长期收益，我可能会卖出。这只股票可能会涨到200，我遇到过这种情况，对这种错误不要太在乎。 我想说我不知道什么时候卖出最好。我基本上一只股票50买入的，涨到100，就比较脆弱了，我可能会卖出。因为已经翻倍了，我不想操心。不过，我们是分批卖出，最好不要在一个价位全部卖出。我可能会在85就卖出部分，具体要看持有了多长时间。我们一般持股在三年左右，不频繁买卖。 对施洛斯来说，他们放弃一般是因为资产恶化或者盈利能力远不如预期。股票可能仍然便宜，但是恢复估值的希望越来越渺茫。 var className='atoc';"},"Finance/Notes/黄奇帆.html":{"url":"Finance/Notes/黄奇帆.html","title":"黄奇帆","keywords":"","body":"《结构性改革》 -- 黄奇帆 金融的本质，就是三句话： 为有钱人理财，为缺钱人融资； 金融企业的核心要义就在于信用、杠杆、风险三个环节，要把握好三个环节和度； 一切金融活动的目的是要为实体经济服务。 这三个本质特征，不管是哪个层面的金融从业者，都应时刻谨记于心。 为有钱人理财，为缺钱人融资 比如银行，老百姓可以存钱，企业发展可以贷款，银行在其中起着桥梁、中介和服务作用。比如保险，实际上是人在健康、安全的时候，用余钱来保障疾病、死亡等意外事件突发时的救急需求，是一个自我平衡的过程，同时也能为企业融资提供资金来源。 证券市场更是如此，老百姓冒一定风险投资购买股票，取得的回报可能是企业利润分配，也可能是股价差价，总归是将余钱用于理财的桥梁。租赁也一样，企业通过租赁，把一次性的巨额投资转化为长期的租赁费用和日常的运行资金，将产生更多的效益，起到融资的作用。 总之，不管是直接金融系统的资本市场发行债券等，还是间接金融系统的商业银行或非银行金融机构，都是各种理财方式、中介方式，本质上是为有钱人理财，为缺钱人融资。 金融企业的核心要义就在于信用、杠杆、风险三个环节，要把握好三个环节和度。 信用 首先，信用是金融的立身之本，是金融的生命线。体现在三个方面：金融企业本身要有信用，与金融机构发生借贷关系的企业要有信用，各种金融中介服务类企业也要有信用。 衡量企业的信用，要把握好五个维度。 现金流。现金流比利润更重要。如果资金链断了，企业崩盘破产，预期利润再高也没有用。所以，资本市场上考核企业信用的第一件事，就是分析企业财务报表的现金流。 回报率。看重企业的成长预期，通过分析未来几年的利润、市盈率予以全面衡量。 抵押担保。如果现金流、回报率无法衡量，但有担保公司或第三方企业愿意提供担保，银行也可放心贷款。 企业高管。一个地方乃至国内外知名的优秀企业家，具备相当高含金量的个人信用，亦可为企业信用加分。 五是企业品牌等无形资产。这些无形资产也应纳入信用评价体系。这些都是金融规律，必须严格遵循。现在常讲大数据分析，但如果分析的结果是不需要有现金流，不需要资本回报，不需要担保物，这种脱离金融本源的分析都是“假大空”的。金融衍生工具也一样，即便种类繁多，也都应该具备信用的基本特征，否则就会导致金融泡沫。 2008年国际金融危机，就是典型的不按规律办事。以商品房为代表的次贷产品出了问题，银行不是想办法在抵押物上做文章，把次贷变成正常贷款，而是把次贷卖到股票市场，变成了CDS（信用违约互换）债券，杠杆比高达1∶40。雷曼兄弟公司40亿美元购买了1 600亿美元CDS债券，如果涨10%，就赚160亿美元，但如果跌10%，就立即崩盘。 总之，一切没有信用的金融都是假金融、伪金融。 其次，杠杆。信用是杠杆的基础，有信用才有透支，透支就会带来杠杆比。银行的存贷比，实质是一种杠杆比。如果一家银行有10亿元资本，可放贷100亿元，就是1∶10的杠杆。租赁公司有50亿元资本，可以搞500亿元租赁，就同样是1∶10的杠杆。搞期货一般是1∶20的杠杆，远期交易是1∶5的杠杆。股票市场搞融资融券，实质也是证券公司给予投资人一定比例的透支。总之，没有杠杆比，大家一手交钱、一手交货，就不需要信用，也不存在金融。 风险, 没有杠杆比谈不上金融，但杠杆比过高则会产生金融风险，这是辩证的关系。一切金融创新，都是想方设法把杠杆比一级一级地放大。过高的杠杆比是一切坏账、一切风险、一切金融危机的来源，在企业层面表现为坏账，在行业系统层面是风险，延伸到国家乃至世界就成了金融危机。唯一的解决办法，就是“去杠杆”。 真正的智慧，应是设计一个信用基础较好、风险较小的杠杆体系，这是金融的精髓。 信用、杠杆和风险这三个方面也是互动的。 信用好，杠杆比不高，风险自然就会低。杠杆比高，信用则会降低，风险也就较高。所有的金融创新，都是围绕这三个方面在运转，关键要把握好其中的度。 尽管这些基本原理是金融课堂的常识，但必须当真经来念，不管是行长还是办事员，都要天天念、月月念、年年念，因为一切金融风险都是背离了这些基本原理而产生的。 所以，把现有信用用足用好，有信用不好好发挥就是死心眼，但是有信用就把杠杆用得过了头造成风险，那也是疯子或者是愚蠢的人。 金融管理的要义就是把自己这个企业的信用用足，但是用足就表现为杠杆的放大，在放大杠杆的时候又要把风险控制在底线里面，这就是一个高明的金融领导人员、管理人员、工作人员、财会人员必须担负的基本责任。 为实体经济服务，是金融的要义 离开实体经济，金融就是无源之水。 金融很重要，金融是现代经济的核心。搞好了，一着棋活，全盘皆活。上海过去是金融中心，是货币自由兑换的地方，今后也要这样搞。中国在金融方面取得国际地位，首先要靠上海。“百业兴，则金融兴；百业稳，则金融稳”，这是金融行业的金科玉律。金融是现代经济的核心，必须要为实体经济服务，否则就会异化为“卡拉OK”、自弹自唱。 这三句话表现在宏观上面，即宏观经济中的货币信用、负债信用、杠杆信用从哪里来？ 一个国家GDP的增长率、财政税收的增长率、实体经济的利润率，是一切货币信用、负债信用、杠杆信用的来源。反过来杠杆过大又会带来宏观经济的风险。 这三句话表现在微观上，即每个企业对自己的债务杠杆、效益改善都应日日关注、月月关注、年年关注，把企业经营好。 在具体的金融工作中，我们可以观察到，已经进入正轨的金融机构都有着管理杠杆的基本制度，有多大的资本才能有多大的杠杆。例如银行有五个信用指标，分别是 资本充足率 贷款利润率 坏账准备金 存款准备金 存贷比 这些都是银行信用的基础。 证券公司也好，小贷公司也好，保险公司也好，凡是“一行两会”批准的、有牌照的金融机构，其信用基础、杠杆比例、风险防范都必须有制度安排，有明确的法律管制或者制度管制。 在这方面，一个金融工作人员只要学习了这些业务并循规蹈矩，把工作做好就可以了，除非金融监管失控才会使乱象丛生。应该说，不管是20世纪80年代、90年代，还是21世纪以后，特别是2008年世界金融危机以来的这十年，银行、证券、保险等传统的、常规的金融机构其实还是基本规范的。 var className='atoc';"},"Finance/Notes/查理芒格.html":{"url":"Finance/Notes/查理芒格.html","title":"查理芒格","keywords":"","body":"查理·芒格读书笔记 你一定要和高水准的人做生意，永远不要和一头猪玩摔跤，因为如果你这么做了，你们两个都会变脏，但是猪会乐在其中 好企业和差企业之间的区别在于，在好企业里你会做出一个接一个的轻松决定，而差企业的决定则常常是痛苦万分的。 我本人是一个传记狂，比如你要是和亚当•斯密成了朋友，那你一定会把经济学得更好。跟离世的伟人交朋友，这听起来很滑稽，但如果你一生都这样做，你会受益匪浅。 投资游戏说到底就是要比其他人对未来做出更准确的预言。要如何做到呢？一种方法是将这种竞争在有限的几个区域中进行。如果你试图预言所有事情的未来，你会因为缺乏专长而失败。 如果你想变得聪明，你就必须不停地问为什么？为什么？为什么？同时你还必须将答案和有条理的深层理论联系起来。你必须知道那些最主要的理论。这稍微会有些费力，但充满乐趣。 我们大多数人做决策时都会存在一个问题：不考虑这个决策可能带来的长远影响。这时，你可以根据 10 → 10 → 10 原则来考虑所做的决策可能带来的长远影响。这个原则就是： 这个决策在 10 分钟后，会产生什么影响？ 这个决策在 10 个月后，会产生什么影响？ 这个决策在 10 年后，会产生什么影响？ 在做决策时如果能践行 10 → 10 → 10 原则，这将有助于你在决策时免受感性因素的影响，迫使你考虑到这个决策可能会带来的长远影响，从而做出更加明智的决策 var className='atoc';"},"Finance/Notes/彼得林奇.html":{"url":"Finance/Notes/彼得林奇.html","title":"彼得林奇","keywords":"","body":"彼得林奇笔记 彼得林奇的经典著作 《战胜华尔街》 《彼得‧林奇的成功投资》 《在华尔街的崛起》 彼得林奇投资风格 投资者指望依靠短线操作赚钱谋生就像指望依靠赛车、赌牌谋生一样，机会非常渺茫。彼得林奇从不关注股价的短期波段，而是将眼光聚焦于上市公司本身。 他认为没有人能预测利率、经济或股市未来的走向，抛开这样的预测，注意观察你已投资的公司究竟在发生什么事。只相信购买卓越公司的股票，特别是那些被低估而且没有被市场正确认识的卓越公司的股票是唯一投资成功之道 彼得林奇对公司的分类 缓慢增长型 稳定增长型 快速增长型 周期型 隐蔽资产型 困境反转型 缓慢增长型 是指增长速度相当于GDP增长速度的公司。在美国是3%左右， 此类公司的股票一般很难有较大的上涨空间，除非出现重大的重组之类的特殊事件，不然的话很难有催化剂让这类公司快速的上涨，股票走势相对会很平坦. 稳定增长型公司 是指增长速度比缓慢增长型稍快且能保持相对稳定的公司。彼得林奇认为的增长速度是10-12%， 此类型股票的投资策略是具有要选择好的时机好的价格进入，而且具有相对的防御型，在股市大跌时此类股票可能会跌的幅度相对小很多，而且下跌后很快就会价值回归 快速增长型公司 这类企业的特点是规模小、新成立不久、成长性强，年平均增长率为20%～25%。快速增长型公司并不一定属于快速增长行业。投资此类公司的股票，应该重点关注最近几年公司的收益增长率，是否在一个以上的城市或者乡镇复制了原有的成功经营模式，股票交易价格的市盈率是否等于或者接近于公司收益增长率，只有很少的机构投资人持有等。投资快速增长型公司要以可能有10倍以上的投资收益作为考虑 这类股票是彼得林奇最喜欢的类型，这也是最容易出现10倍甚至百倍股票的地方。快速增长型公司并不一定属于快速增长型行业的公司，也有可能在夕阳行业中脱颖而出的小公司，这更得到彼得林奇的钟爱。这类公司可以通过不断争夺别家公司的市场份额来成长。但是快速增长型公司也存在着一定的风险，尤其是那些扩张过快但是资产负债不够健康的企业，经常由于管理层头脑发热导致资金链断裂而出现危机。 在投资快速增长性公司是，一要看公司未来增长空间和时间有多大，二要看公司资产负债表是否足够健康稳健。 周期型公司 这类公司的特点是其收益情况随着经济周期不断的扩张、收缩、再扩张、再收缩，周而复始。其收益在扩张期可能高达数十亿，在收缩期却可能亏损数十亿 汽车和航空公司、轮胎公司、钢铁公司以及化学公司都是周期型公司，甚至国防工业公司的行为也像周期型公司，因为它们的盈利随着各届政府政策的变化而相应上升与下降。 时机选择是投资周期型公司股票的关键，你必须能够发现公司业务衰退或者繁荣的早期迹象。如果你在与钢铁、铝业、航空、汽车等有关的行业中工作，那么你已经具备了投资周期型公司股票的特殊优势，与其他任何类型的股票投资相比，这种特殊优势在周期型股票投资中尤其重要。 资产隐蔽型公司 此类公司有很多的资产未反映在资产负债表数据当中，或者反映的是其原始价值。比如某个公司的土地记得是购买时的价格，现在已经翻了数倍。还有可能公司有一些古董。投资者一旦发现公司股价未反映公司的隐蔽资产，则应当买入等待价值发现。 最大的有线电视公司的股票数量非常之少，主要是因为当时我没能认识到这家公司资产的真正价值。当时这家公司不仅收益少得可怜而且负债高得吓人，从传统的观点来看，有线电视并不是一项很有吸引力的业务，但是该公司的资产（表现为有线电视用户）的巨大价值却远远超过了这些负面因素的影响，所有了解有线电视 逆境反转型公司 此类公司一般是已经处于破产的边缘或者经营已经非常困难，由于某一特殊事件比如政府救济、资产重组等导致经营出现好转，从破产中起死回生。资产重组概念就是属于此类。 彼得林奇对业余投资者的建议 每个人都有属于自己的能力圈，专注于自己熟悉的领域，利用自身所掌握的专业知识和经验，充分挖掘自身潜力，可以提高投资成功的概率 作为一个业余投资者，你的优势并不在于从华尔街投资专家那里获得的所谓专业投资建议。你的优势其实在于你自身所具有的独特知识和经验。如果你充分发挥你的独特优势来投资于你充分了解的公司和行业，那么你肯定会打败那些投资专家们 搞清楚股票背后的公司 每只股票后面其实都是一家公司，你得弄清楚这家公司到底是如何经营的 一定要研究基本面 不研究过公司基本面就买股票，就像不看牌就打牌一样，投资赚钱的机会很小 长期持有 当你持有好公司的股票时，时间就会站在你这一边，持有时间越长，赚钱的机会越大。耐心持有好公司股票终将有好回报，即使错过了像沃尔玛这样的优秀公司股票前5年的大涨，未来5年内长期持有仍然会有很好的回报 投资是反人性的，要抵抗人性的弱点 最后，至关重要的是你要能够抵抗得了你自己人性的弱点以及内心的直觉。绝大多数的投资者内心的一个秘密角落里都会隐藏着一种自信，觉得自己拥有一种预测股票价格、黄金价格或者利率的神奇能力，尽管事实上这种虚妄的自信早已经一次又一次地被客观现实击得粉碎。让人感到不可思议的是，每当大多数的投资者强烈地预感到股价将会上涨或者经济将要好转时，却往往是正好相反的情况出现了。这一情况已经被那些十分流行的投资咨询时事通讯服务机构的调查所证明，尽管他们自己也经常在不适当的时候发表股市是牛是熊的错误预测。 var className='atoc';"},"Finance/Notes/邱国鹭.html":{"url":"Finance/Notes/邱国鹭.html","title":"邱国鹭","keywords":"","body":"邱国鹭 总结 投资的三个基本问题（选股三要素） 估值：便宜才是硬道理，横向纵向比，市值与未来成长空间比，最接近科学，比较简单可以判断。 品质：是不是好行业（公司是否有定价权. 行业格局是否良性. 竞争是否激烈，好喊行业赚钱不辛苦，不好的行业辛苦不赚钱）. 差异化竞争（品牌. 回头客. 转换成本. 单价不高. 服务网络. 先发优势），品质就是研究是不是好生意，需要花大力气研究。 时机：可以理解为技术分析，是一种艺术，精准抄底和逃顶太难，应该尽量淡化。 买到价格合理的伟大公司难度超过价格低谷的普通公司，逆向投资不是一种技能，是一种品格，买早了还熬得住是必备素质。 在好的行业里挑选好的公司，然后等待好价格出现时买入，买到便宜的好公司 宁可数月亮，不数星星 月朗星稀的行业最好：寡头垄断行业的龙头股竞争有序、坐地收钱，仍然有很大涨幅可以享受，百舸争流的行业，增长再快也很难找到好的投资标的，买黑马股类似赌石 价值陷阱和成长陷阱 价值陷阱：再便宜也不应该买的公司， 基本面持续恶化，越跌越贵。 技术淘汰 赢者通吃行业里的小公司 分散重资产夕阳行业 景气定点的周期股 会计欺诈公司 黄金坑还是价值陷阱主要判断导致下跌的原因是永久性的还是暂时性的。 成长陷阱： 估值过高 技术路径踏空 无利润增长 盲目多元化、寄生式增长、强弩之末 真假风险 感受到的风险，真正的风险：指数上涨感受的风险减少，真正的风险增加，反之亦然。 暴露的风险和隐藏的风险：承担暴露的风险，风险已经体现在价格里，规避隐藏的风险，这种风险不会产生高收益。 价值投资的局限性 内在价值确定难：部分行业价值判断不确定性大。只能趋势投资。 反身性： 部分公司股价变动反过来影响公司价值，比如部分高质押爆仓引发的公司融资风险。 市场阶段： 熊末牛初价值投资最好用，熊市初期会超跌，牛市末期会超涨，傻瓜定价说。 投资期限： 价值投资需要漫长等待。波动炒作快进快出是伪夹头。 投资心理学 投资者常见的心理 屁股决定脑袋：重仓股只解读为好消息 锚固偏见：股票便宜与否不应该看涨幅，应该看估值。 心里账户：把买入成本作为了投资决策的依据 知易行难：价值投资知易行难 var className='atoc';"},"Finance/Notes/戴维斯.html":{"url":"Finance/Notes/戴维斯.html","title":"戴维斯","keywords":"","body":"戴维斯 总结 戴维斯家族的投资历程，经历了2次漫长的牛市，25次调整、2次严酷的熊市、1次大崩盘、7次温和的熊市、9次衰退；第二次世界大战、冷战、人类登月、石油危机、“漂亮五十”的崛起与崩溃；1次总统遇刺、1次总统辞职、1次总统遭到弹劾；34年的利率上升和18年的利率下降…… 戴维斯理念 戴维斯投资金融类股票的根本原因是——-金钱永不过时 投资就是跑马拉松 以合理的价格购买适度增长的公司股票， 如果价格不合理，那么耐心等待合理价格的出现，而买入后，他们可以甚至可以持有一生，这种 “买入并持有”的投资策略可以降低交易成本，减少由于频繁交易而引发的失误。用第三代传人克里斯的话说 “以1年、3年、甚至5年的时间看，股票是危险的，但是放眼10年、15年却是不同的景象”、“我们在跑马拉松”。 青睐于投资保险业 戴维斯热衷投资保险股主要有以下几点： 保险业是非周期性的永续经营行业； 保险公司掩盖了其真实的盈利和资产； 保险业时常被市场忽视，常常有极低的价格。 戴维斯认为保险公司是不动声色的成长公司，他专心寻找购买基本面稳固且具有光明前景的保险公司，特别是小型、进取类型的保险公司股票。一旦确定公司盈利，他会将注意力转移到公司资产赖以取得复利增长的投资组合上。 以合理的价格购买适度增长的价格适中的公司股票 戴维斯家族既不投资廉价股，也不投资高价股。随着资产规模的扩大，他们不再仅仅聚焦于保险股，而是将选股范围扩展到更多行业，在坚持使用“戴维斯双击”策略的同时，开始积极投资成长股。戴维斯（第三代）认为，选择收益增长速度高于股票市盈率的公司才是理想的投资。 好的投资对象应该是成长率高于市盈率的公司。他会避免购买“狂野”类股票，会寻找那些“一般”类的股票。这个“一般”的股票仅仅具有13％的成长率，并不引人瞩目，股价是10倍市盈率。如果这个“一般” 的股票能保持5年这样的表现，并吸引投资者愿意支付15倍的市盈率，那么，耐心的投资者就会在5年之间获得20％的年化回报，而“狂野”类的热门股票仅能获得6％的回报。 而戴维斯家族选择的公司大都具备以下特征： 公司所售的产品或服务永不过时，在国内外运作良好，在市场上占据优势或处于上升地位； 开展创新研究，保持最低开支，善于收购对手，并能增加盈利； 股东资本回报率高，资产负债表良好； 有一流、诚信的管理层，并且持有大量公司股份。 不要购买廉价股 一些最廉价的股票或许就值那个钱，因为那些公司多是平庸的公司。问题在于，一个平庸的公司会一直保持平庸 避开高价股 价格昂贵的股票或许物有所值，因为他们可能代表着伟大的公司。但戴维斯却拒绝购买这类股票，除非它们的价格相对于其盈利水平合理。戴维斯一家从来不会为衣服、房子或度假支付过分的价格。为什么投资者要为盈利支付过分的价格呢？说到底，人们买的不就是公司的盈利吗？ 逆向投资, 危机中买入 用戴维斯的话说熊市会帮你赚钱。当电视评论员还在讨论1987年是否会是1929年大危机翻版时，戴维斯已经开始兴奋地动手买进 忽略后视镜,忘记过去 “电脑技术的发展使得投资者过于关注过去无穷的数据，” 谢尔比说，“人们从来没有像现在一样，致力于从过去找到未来。”华尔街的历史上最有价值的总结就是， 历史从来不会一成不变地重复过去。 投资于优秀的管理层,信赖卓越管理 戴维斯投资于那些伟大的管理层，谢尔比也遵循同样的逻辑。如果一个伟大的领导人离开一家公司到了另一家，谢尔比会将资金投入新的公司，这是再次购买管理人才能的行为。“任何公司的成功都离不开优秀的管理层，这是华尔街公认的真理。但是，一般的分析师会忽略这一点，”克里斯说，“分析师们总爱讨论最新的数据，但在没有评估过领导层情况时，我们从来不会做任何投资。” 72法则 72法则告诉我们，基于回报率的不同，需要多长时间可以将投资本金翻一番。如果是投资债券，回报率是可预测的，但投资股票，你只能有根据地推测回报率。 　假设最初投资金额为100元，复息年利率9%，利用72法则，将72除以9，得8，即需约8年时间，投资金额滚存至200元，而准确需时为8.0432年。 戴维斯双击 Price（股价）= PE（市盈率）* EPS（每股盈利） 戴维斯双击是指在低市盈率(PE)买入股票，待成长潜力显现后，以高市盈率卖出，这样可以获取每股收益（EPS）和市盈率(PE)同时增长的倍乘效益。这种投入策略被称为\"戴维斯双击\"。 在市场低迷的时候寻找EPS和PE处于低位的股票，在预计盈利进入上升的拐点时买入，等待股市行情回暖，同时公司盈利回升，从而PE和EPS一齐上升，带来股价的迅猛攀升 戴维斯双杀 戴维斯双杀效应是指有关市场预期与上市公司价格波动之间的双倍数效应 即在市场疯狂的时候，买入PE很高，同时EPS处于顶峰拐点的股票，当股市走弱，同时公司盈利下滑，带来PE和EPS一齐下降，导致股价的大幅下跌 当上市公司的业绩逐渐下滑，利润增长率也会随之下滑，那么每股收益也下降，市场或投资者对于该公司的估值也随之下降，股价相应的得到相乘倍数的下跌 var className='atoc';"},"Finance/Notes/巴菲特.html":{"url":"Finance/Notes/巴菲特.html","title":"巴菲特","keywords":"","body":"# var className='atoc';"},"Finance/Notes/格雷厄姆.html":{"url":"Finance/Notes/格雷厄姆.html","title":"格雷厄姆","keywords":"","body":"# var className='atoc';"},"Finance/Notes/曼昆.html":{"url":"Finance/Notes/曼昆.html","title":"曼昆","keywords":"","body":"曼昆 《经济学原理》 经济学十大原理 人们面临权衡取舍 认识到生活中的权衡取舍是重要的，因为人们只有了解了他们面临的选择，才能做出良好的决策。 我们在日常生活中，总是面临很多取舍的，比方说，先买房子还是先买车 某种东西的成本是为了得到它而放弃的东西 一种东西的机会成本（Opportunity Cost）是为了得到这种东西所放弃的东西, 你干一件事情或者得到一件东西的成本，不仅仅是花的钱，还有为此放弃的东西 理性人考虑边际量 “边际量”是指某个经济变量在一定的影响因素下发生的变动量。个人和企业通过考虑边际量，将会做出更好的决策 理性人明白，生活中的许多决策很少是黑与白的选择，而往往涉及到灰色阴影。当到了吃午饭的时间时，你面临的决策不是在快餐或猪排之间的选择，而是是否再多吃一勺土豆泥。当考试临近时,你的决策不是在放弃考试或一天学习2 4个小时之间的选择，而是是否多花一小时复习功课而不看电视。经济学家用边际变动（marginal change ）这个术语来描述对现有行动计划的微小增量调整。记住“边际”指“边缘”，因此，边际变动是围绕你所做的事的边缘的调整。在许多情况下，人们通过考虑边际量来做出最优决策 人们会对激励作出反应。 由于人们通过比较成本与利益做出决策，所以，当成本或利益变动时，人们的行为也会改变。这就是说，人们会对激励做出反应 在分析理解一些行为时，激励是至关重要的。例如，车厘子价格上涨人们会考虑吃其他水果；汽油价格的上涨，人们开始选择公共交通工具； 贸易能使每个人状况更好。 从某种意义上说，经济中每个家庭都与所有其他家庭竞争。尽管有这种竞争，但把你的家庭与所有其他家庭隔绝开来并不会使大家过得更好。 一个人可以在生产所有物品上都拥有绝对优势，却不可能在生产所有物品上都具有比较优势，而专业化和贸易的好处就是基于比较优势的，因为每个人都具有自己的比较优势，于是交易就变得有利可图了，其奥妙就在于，用于交易的商品，其价格一定是低于自己生产的机会成本的 贸易可以使社会上每个人都获利，因为它使人们可以专门从事他们具有比较优势的活动，也就是我们常说的，专业的人做专业的事，这样是利益最大化的。 市场通常是组织经济活动的一种好方法。 企业和家庭在市场上相互交易，价格和个人利益引导着他们的决策。 自由市场可以使资源得到最合理的分配（使用价格工具），也就是所谓的“无形的手” 政府有时可以改善市场结果。 为什么我们需要政府呢？一种回答是，看不见的手需要政府来保护它。只有产权得到保障，市场才能运行。但是，还有另一种回答。政府干预经济的原因有两类：促进效率和促进平等。 一国的生活水平取决于它生产物品与劳务的能力。 世界各国生活水平的差别是惊人的。随着时间推移，生活水平的变化也很大。 一个国家，生产的东西（包括服务）越多，生活水平就越高 当政府发行了过多货币时，物价上升。 当一个政府创造了大量本国货币时，货币的价值下降了, 通货膨胀是经济中物价总水平的上升。 社会面临通货膨胀与失业之间的短期交替关系。 人们通常认为降低通货膨胀会引起失业暂时增加。通货膨胀与失业之间的这种交替关系被称为菲利普斯曲线。 当政府减少货币量时，它就减少了人们支出的数量。较低的支出与居高不下的价格结合在一起就减少了企业销售的物品与劳务量。销售量减少又引起企业解雇工人，就暂时增加了失业 var className='atoc';"},"Finance/Accounting/A股财报披露知识.html":{"url":"Finance/Accounting/A股财报披露知识.html","title":"A股财报披露知识","keywords":"","body":"A股财报披露知识 财报年度 在部分国家和地区，企业可以按照行业或者企业的经营特点，自己设定经营年度的起止日。比如在美国和中国香港两地上市的阿里巴巴，它的财报年度就是从当年的4月1日至第二年的3月31日，即4月到6月算第一个季度，以此类推。 我国上市公司，通通按照自然年（1月1日至12月31日）为经营年度，并按季度披露一季报，半年报（也称'中报'），三季报和年报 财报的披露时间 在年度结束后4个月内披露年报（4月30日之前）年报必须经会计事务所审计并出具审计意见 在一季度结束后1个月内披露一季报（4月30日之前）注意：一季报的披露时间不得早于年报 在二季度结束后2个月内披露半年报（8月31日之前）在三季度结束后1个月内披露三季报（10月31日之前） 业绩预告（业绩快报） 上市公司还要按照交易所的要求，提前发布业绩预告或业绩快报 上海证券交易所 上海证券交易所规定，在上海证券交易所上市的企业，若预计全年可能出现以下三种情况之一，应当在1月31日前披露业绩预告 情况1：亏损 情况2：扭亏为盈 情况3：实现盈利，且利润同比增长或下降50%以上 对于半年报和季报业绩预告，上海证券交易所鼓励公司资源披露 深圳证券交易所 深圳证券交易所规定，在深圳证券交易所上市的企业，在季报，半年报以及年报前，如果预计将出现以下五种情况之一，应当披露业绩预告 情况1：亏损 情况2：扭亏为盈 情况3：实现盈利，且利润同比增长或下降50%以上 情况4：期末净资产为负值 情况5：年度营业收入低于1000万人民币 其中符合情况3但是基数较小的，可以申请豁免披露，基数较小的定义满足下面任意一条即可： 上一年度每股收益不高于0.05元 上一年前三季度每股收益不高于0.04元 上一年半年度每股收益不高于0.03元 上一年一季度每股收益不高于0.02元 深圳证券交易所对披露业绩预告的时间要求为 年度业绩预告不晚于次年的1月31日 一季度业绩预告不晚于4月15日 半年度业绩预告不晚于7月15日 三季度业绩预告不晚于10月15日 var className='atoc';"},"Finance/Accounting/财报入门.html":{"url":"Finance/Accounting/财报入门.html","title":"财报入门","keywords":"","body":"财报入门 投资一家公司， 阅读公司的财务报告真的太重要了，看大佬们是如何说的, 个人投资者建议学会做减法， 选择自己能够看懂的公司去研究，放弃太难的公司， 坚守自己的能力圈 巴菲特: 买股票的本质是投资公司 彼得林奇： 当你读不懂某一公司的财务情况时，不要投资。股市的最大的亏损源于投资了在资产负债方面很糟糕的公司。先看资产负债表，搞清该公司是否有偿债能力，然后再投钱冒险 财务报表分类 财务报表分三类 利润表 资产负债表 现金流量表 在看公司公司财报前，先看会计师审计报告，在年报的第十一节，《审计意见》，审计意见反映了审计师的心声 利润表 形象解释 净利润中包含了企业的应收账款，所以并不能单单以净利润在决定公司运营好坏，还需结合现金流量表和资产负债表 扣非净利润 归属于母公司所有者的净利润 资产负债表 资产 负债 流动资产 说明 非流动资产 说明 负债 说明 所有者权益 说明 货币资金 企业的现金存款 固定资产 非货币资产，(房屋，设备，机器等) 银行负债 银行贷款 股东出钱 应收账款 发了货，还没结账，(坏账准备) 生物性资产 农林牧渔行业 存货 看行业，更新快的行业存货少好 无形资产 专利权，著作权，土地使用权 表格在手机上会有变形，截图如下 现金流量表 序号 类别 说明 1 经营活动产生的现金流量 利润表收入支出现金的变化 2 投资活动产生的现金流量 资产负债表的固定资产变动情况 3 筹资活动产生的现金流量 资产负债表的负债和所有者权益变动情况 1. 经营活动现金流 有公开数据的企业，直接看企业经营活动产生的现金流，这是现金流量表的核心。因为刚刚我们刚讲了，企业的经营能力才是我们投资者最应该看重的。而经营活动现金流，就代表着经营能力的强弱。 如果经营活动现金流量净额，长期为负的话（银行证券保险除外），代表企业日子不太好过，入不敷出，这类企业不用考虑投资。只有经营活动现金流量净额是正数，说明它才是一家正常的企业。 2. 投资活动现金流 3. 筹资活动中了解企业的融资情况 类型一、“+++”的企业 三项都为正的企业。表明上看起来，这样的公司特别不错。经营活动现金为正数，现金源源不断。但是有一个问题，就是企业经营赚了钱以后，为什么不向外投资呢？反而还需要筹资呢？难道都把钱放在银行账户上数钱玩吗？这类型的企业，要么就是即将大规模的开展对外大规模的投资活动，所以在筹集本钱。要么就很可能是起了歹心，借着上市公司的躯壳在赚钱。所以，如果是这三项都是正的企业，建议我们要谨慎观察一下。如果查阅很多材料，都看不出来企业有大投资的动作。建议这类型的企业，我们也淘汰掉。 类型二、“++-”的企业 这类型的企业，经营活动现金流为正，说明企业经营情况还不错。投资活动现金流为正，说明以前投资的资产，带来了利息等方面的收入。或者是变卖了资产，产生了收入。一般来说，资产带来的收益比较多，因为企业变卖资产的情况很小。筹资活动现金流为负数，要么就是还了贷款，要么就是给股东分红。这类的企业，如果投资现金流，不是变卖资产所得。而经营现金流和投资现金流，足以覆盖筹资现金流的流出。我们就可以初步判断，这家公司是健康发展的。 类型三、“+-+”的企业 这类企业，经营活动现金流同样为正，说明企业赚钱。同时筹资活动现金流为正，但是投资活动现金流是负。说明企业现在正在大力的扩大规模。需要把钱投入到新的项目中。这类企业有一个问题，就是所投资的项目如果创造辉煌，企业会高速的增长。反之，企业如果投资失败，会影响企业后期的发展。 这类型的企业，很考验我们对行业发展的一个判断。 类型四、“+--”的企业 经营活动现金流为正，同样说明企业赚钱。投资活动现金流为负，说明企业也在稳步的扩张。筹资活动现金流为负，说明企业还了贷款，或者给股东分红了。也就是说，企业靠着经营现金流的流入，实施了投资，并且同时还了贷款或给股东分红。这类型的企业是四种画像里面最好的企业，这种企业自我造血能力最强。靠着自己赚的钱可以去投资其他的项目，同时赚的钱还可以给股东分红或者偿还贷款。这类企业是最具备投资价值的 var className='atoc';"},"Finance/Accounting/财报思维导图.html":{"url":"Finance/Accounting/财报思维导图.html","title":"财报思维导图","keywords":"","body":"财务报表的思维导图梳理 财报被操纵的痕迹 操纵手法 利润表总结 利润表 速读利润表 现金流 现金流肖像 现金流速读 现金流量表 资产负债表 生产相关资产 经营相关资产 货币资金 投资相关资产 var className='atoc';"},"Finance/Accounting/利润表.html":{"url":"Finance/Accounting/利润表.html","title":"利润表","keywords":"","body":"利润表 总结 核心概念 核算方式的不同 收付实现制 日常生活核算方式 以现金的收和支来界定收入和费用 收入: 收到手上的现金 支出： 支出去的现金 权责发生制 企业会计核算方式 以权利或责任的发生 来确定收入和费用 收入: 取得收到现金的权利 支出： 支付现金的责任 报表的不同口径 合并利润表 母公司+其控制全部子公司所构成的财务报表主体 母公司利润表 母公司独立法人的单体财务报表 营业收入 确认方式 了解企业营业收入确认原则相当重要，第一次阅读某公司财报时一定要看营业收入确认原则，输入“满足以下条件时确认“进行搜索 意义 展示企业经营状况和发展趋势 企业增长方式 不仅要看营业收入绝对数增长，还要看增速是否高于行业平均水平, 持续的增长相当艰难, 要防止过手乐观 潜在需求增长 (可靠性最强) 市场份额扩大 (要评价竞争对手的强弱) 价格提升 (要评估消费的替代性强弱) 营业总成本 营业成本 期内销售产品的存货价值 营业税金及附加 营业过程中无论是否盈利都要缴纳的税费 营业费用 销售费用 为销售商品或服务产生的费用 促销费 广告费 销售机构固定资产折旧 管理费用 与企业管理环节有关的费用(就是个垃圾筐) 管理者工资 工会经费、职工教育经费 行政开支 董事会经费 计提的各类准备 财务费用 企业在生产经营过程中为筹集资金而发生的各项费用 利息支出 利息收入（扣减） 资本化的利息支出（扣减） 汇兑损益 金融机构相关手续费 现金折扣 其他财务费用 财务费用为正（利息收支相抵后，是净支出） 财务费用为员（利息收支相低后，是净收入) 资产减值损失 用资产减值损失计提操纵利润的手法 不提或少提，增加当期利润 多提，减少当期利润，以后转回增加后期财报利润 一次性计提减值损失，降低资产账面值，从而减少后期折旧和摊销，增加后期财报利润 科目数字的说明 科目数字为正(代表有资产减值产生) 科目数字为正负(代表某笔计提减值损失的存货、坏账或债权，又被收回了) 科目数字小(正常) 其它收益 公允价值变动收益 投资收量 汇兑收益 观察重点 重点观察企业历史营业费用变化趋势，与同行业的差异等 费用率 费用 = 销售费用＋管理费用＋财务费用 费用率 = 费用 / 营业总收入 费用率较高的公司 产品缺少接力，必须要营销推力完成销售 对管理能力要求极高 费用率剧烈变化的公司 销售策略不稳定 管理费用增长比例大于营业收入增幅 要找出发生了什么变化? 尤其需要注意已经出现出现小额净利润的公司 观察“费用/毛利润”的比率 30%以内(优秀企业) 30% -70%(有一定竞争优势的企业) 70%以上(不用再关注研究了) 对研发费用的辦证思考 高研发费用企业 可能风险大，经营前景不明 可能成功回报巨大 毛利润 毛利润 毛利润 = 主营业务收入 一 营业成本 毛利率 毛利率 = 毛利润 / 主营业务收入 毛利率与同行业企业比较，远高出同行业的企业，要么是业内强者，要么足造假骗子 高毛利率意味着公司的产品具有很强的竟争优势，替代品少或替代成本高 意味着公司的产品存在大量替代品且替代成本低 毛利率变化的原因 毛利率提高 成本下降 售价上升 毛利率降低 成本上升 售价下降 常见毛利率标准 30%以上(企业具有某种持续竞争优势) 信息技术行业 医药生物行业 食品饮料行业 餐饮旅游行业 文化传播行业 房地产行业 30%以下(企业处于高度竞争的环墳中) 20%以下(竞争非常激烈，不建议去研究投资) 企业获得利润的三种模式 茅台模式 高毛利 代表产品竞争力的强弱(需关注产品口碑， 竞争品替代情况) 沃尔玛模式 高周转 代表管理层运营能力的强弱(需关注管理层的变动) 银行模式 高杠杆 代表企业承担的风险大小(需关注宏观经济，资金供需) 营业外收支 如果企业利间主要部分经常来自营业外收入，背后有陷阱的可能性很大 营业外收入 与主营业业务无直接关系的偶发性收入 非流动资产处置利得 非货币性资产交换利得 出售无形资产收益 债务重组收益 政府补助 债权人放弃债权 企业合并损益 营业外支出 与主营业务无直接关系的偶发性支出 非流动性资产损失 非货币性资产交换损失 债务重组损失 营业外支出 公益性捐赠支出 行政罚款 固定资产盘亏、报废、毁损陷阱 营业利润 营业利润 = 营业收入 - 营业成本 - 营业税金及附加 - 销售费用 - 管理费用 - 财务费用 - 资产减值损失 + 公允价值变动损益(-公允价值变动损失) + 投资收益(-投资损失) 营业利润率 = (营业利润 / 营业收入）×100% 营业利润率代表了企业通过生产经营获得利润的能力，营业利润率比率越高，说明企业的盈利能力越强 利润总额 利润总额 = 营业利润 + 营业外收入 - 营业外支出 净利润 净利润 = 利润总额 - 所得税费用 = 营业利润 + 营业外收支净额 - 所得税费用 净利润并不是公司挣到的钱， 记住企业会计使用权责发生制， 有利润并不代表有钱 var className='atoc';"},"Finance/Accounting/资产负债表.html":{"url":"Finance/Accounting/资产负债表.html","title":"资产负债表","keywords":"","body":"资产负债表 资产负债表是一张平衡表，资产（Asset）= 负债（Debt）+ 股东权益（Equity） 资产负债表不像利润表那样有固定的报表周期，企业可以编制一年中任何一天的资产负债表，我们可以把它看作是公司财务状况在特定时刻的一张“快照”。 通常情况下，企业会在每个季度和每个会计年度的最后一天编制资产负债表 资产部分 什么是资产 企业所拥有或控制的、预期会给企业带来经济利益的资源 资产是由企业过去的交易或者事项形成的 资产是企业拥有或者控制的资源 资产预期会给企业带来经济利益 流动资产 预计在一个正常营业周期中变现、出售或耗用，或者主要为交易目的而持有，或者预计在资产负债表日起1年内(含一年)变现的资产，以及自资产负债表日起1年内交换其他资产或清偿负债的能力不受限制的现金或现金等价物 举例： 库存现金 银行存款 交易性金融资产 应收及预付款项 存货等 非流动资产 非流动资产是流动资产以外的资产 举例： 长期股权投资 固定资产 无形资产等 负债部分 负债 企业过去的交易或者事项形成的，预期会导致经济利益流出企业的现时义务 负债是由企业过去的交易或者事项形成的 负债是企业承担的现时义务 负债预期会导致经济利益流出企业 流动负债 预计在一个正常营业周期中偿还，或者主要为交易目的而持有，或者自资产负债表日起1年内(含一年)到期应予以清偿，或者企业无权自主地将清偿推迟至资产负债表日以后1年以上的负债。 举例： 短期借款 应付票据 应付账款 预收账款 应付职工薪酬 应交税费 应付股利等 非流动负债 流动负债以外的负债。 举例： 长期借款 应付债券 长期应付款 资产负债表结构 资产负债表分两部分 资产项目(左边或上边) 负债及所有者权益(右边或下边) “资产 = 负债 十 所有者权益”， 可以反映资产、负债、所有者权益之间的内在关系， 资产部分的排列 大体按资产的流动性的容易程度排列，流动性大的资产如“货币资金”、“交易性金融资产”等排在前面，流动性小的资产如“长期股权投资”、“固定资产”等排在后面 负债及所有者权益的排列 一般按要求清偿时间的先后顺序排列，“短期借款”、“应付票据”、“应付账款”等需要在一年以内或者长于一年的一个正常营业周期内偿还的流动负债排在前面，“长期借款”等在一年以上才需偿还的非流动负债排在中间，在企业清算之前不需要偿还的所有者权益项目排在后面。 资产负债表图示 编制单位: xx公司 xx时间 流动资产 流动负债 货币资金 短期借款 交易型金融资产 交易型金融负债 应收票据 应付票据 应收账款 应付账款 预付账款 预收款 应收利息 合同负债 应收股利 应付职工薪酬 其它应收款 应付税费 存货 应付利息 一年内到期的非流动资产 应付股利 其他流动资产 其它应付款 一年内到期的非流动负债 其它流动负债 流动资产合计 流动负债合计 非流动部分 非流动资产 非流动负债 可供出售金融资产 长期借款 持有至到期投资 应付债券 长期应收款 长期应付款 长期股权投资 专项应付款 投资性房地产 预计负债 固定资产 递延所得税负债 固定资产清理 其他非流动负债 在建工程 无形资产 商誉 长期待摊费用 递延所得税资产 其它非流动资产 非流动资产合计 非流动负债合计 所有者权益 股东权益(所有者权益) 解释 实收资本（或股本） 实际投入的资本 资本公积 资本溢价评估增值的公积金 减库存股 企业回购自身股票 盈余公积 提取的具有特定用途的 未分配利润 分配利润后留存在企业 按资产用途分类 生产相关资产 固定资产 经营管理而持有的使用寿命超过12个月的，价值比较大的非货币性资产 范围: 房屋 建筑物 机器 机械 运输工具 其他与生产经营活动有关的设备、器具、工具等 折旧: 折旧不付现金，作为当期费用从利润表中扣除 方法：(如果折旧方法突然变更，需要特别警惕) 年限平均法(年折旧额=(原价-预计净残值)÷预计使用年限) 工作量法 双倍余额递减法 年数总和法 排除方法: 优秀企业: 快速折旧，增加前期费用，减少前期利润 较差企业: 拉长折旧时间， 减少当期费用， 做大当期利润 在建工程 项目已经开工，发生了财务支出，但尚未全部完成验收转成固定资产 疑点: 远迟不转入固定资产科目 在建工程数目巨大 减少当期折旧，美化利润 通过在建工程付钱给虛构或关联供应商，再通过采购公司商品或服务，变成收入回流公司，最后由在建工程通过大此例折/旧或计提高额减值积失，达到毁尸灭迹 无形资产 企业拥有或者控制的没有实物形态的可辨认非货币性资产 无形资产的折旧叫摊销 无形资产研发(判断是机会还是风险要理解行业、理解企业) 周期长 投入大 收益大但不确定 商誉 企业获利能力超过可辩认净资产的正常获利能力超出部分 是由另 外一种资产带来的，这种资产就叫商誉 去掉商誉再看公司的负债率，商誉占净资产比例过高的要特别警惕 长期待摊费用 企业已经支出，但摊销期限在1年以上（不含1年）的各项费用 典型的应用： 装修费 租入的固定资产的改扩建、大修理支出 已经提足折旧的固定资产的大修理 递延所得税资产和负债 企业会享受一些税收优惠免缴政策，加倍税前扣除一部分成本费用等，而利润表的编制是按照会计准则进行，并不会考虑上述这些税法上的特殊规定。所以公司并不是按照利润表上的所得税费用缴纳税费。两者之间的差异，就是“递延” 经营相关资产 存货 存货是指企业在日常活动中持有的以备出售的产成品或商品、处在生产过程中的在产品、在生产过程或提供劳务过程中耗用的材料、物料 存货的内容： 原材料 在产品 半成品 产成品 库存商品 周转材料（包装物、低值易耗品） 生物资产 生物资产指有生命的动物和植物，一般出现在农林渔牧行业 造假高发地 税收优惠多,产品不易核查； 产品差异大，不易找到价格参照物； 产品没有移交或交货量大小不易监控 造假成本低容易产生造假的行业: 农林牧渔 软件 集成电路 生物科技 应收票据 应收账款 长期应收款 其他应收款 应收利息 应收股息 应付账款 投资相关资产 交易型金融资产 持有至到期投资部 可供出售金融资产 买入返售金融资产 长期股权投资 投资性 房地产 货币资金 现金及现金等价物 库存现金 银行存款 其他货币资金(企业因指定目的而存在银行某专户里的钱 期限较短的承兑汇票) 存放中央银行随时可以支取的备付金 存放同业款项 同业间买入返售证券 企业持有的期限短、流动性强、风险小的投资 使用受限制的货币资金 不能随时支取的定期存款 存放于央行的法定准备金 交易型金融资产 指公司打算短期持有获取差价的债券、股票、基金、权证等金融资产 在财报中搜索\"持有其他上市公司”即可搜索 特点： 不需要计提折旧 直接以持有期的公允价值变动作为档期损益，进入利润表 买入交易费用直接作为当期费用从利润表中扣除 分红或利息，作为投资收益，计入利润表查找 var className='atoc';"},"Finance/Accounting/现金流量表.html":{"url":"Finance/Accounting/现金流量表.html","title":"现金流量表","keywords":"","body":"现金流量表 现金流量表（cash flow statement）反映企业在一定会计期间'现金及现金等价物'流入和流出的报表, 是站在'风险'的角度，揭示企业的风险状况和持续经营能力，通俗的将就是描述一家企业能否生存下去 展示企业现金活动的三大板块 经营活动现金流(OCF) 企业一段时期经营活动所产生的现金流，是以收付实现制为基础得到的，而利润表中的收入和成本是以权责发生制为基础的。将经营活动现金流与营业收入、营业成本等结合起来分析能更好的了解企业的经营状况, 相对于净利润而言，企业的经营活动现金流量更能反映企业真实的经营成果 现金流入 销售商品，提供劳务获得的现金 收到税费的返还 收到其它与经营活动相关的现金 现金流出 支付给职工以及为职工支付的现金 支付的各种税费 支付的其它和经营活动相关的现金 经营活动现金流 主要有两种方法来计算， 直接法 间接法 筹资活动现金流注意事项 一般情况下，经营活动产生的现金流量净额为负的企业，其日子是不太好过的，这种企业很明显是入不敷出，若是连续为负，其资金链极有可能会出现问题，企业在这样的情况下需要筹钱维持企业经营（金融类和投资类企业除外，对于这类企业来说，投资是其主营业务之一） 经营活动现金流量净额与公司产生的净利润金额相差很小或者大于净利润，这代表企业能将销售产品或者提供劳务所得的净利润转化成实实在在的现金，而不是一大堆应收账款， 也反映了企业在产业链中的地位比较强势，这是优秀公司的典型特征（房地产企业除外，因为房地产企业往往都有大量的预收款) 经营活动产生的现金流量净额如果在以往年份远远低于净利润甚至为负，投资者应当深究其内因，这种情况一般说明企业只是“纸面金贵”，销售了产品但是收不回来钱，其应收账款与应收商业承兑汇票的和值往往占营收比重会较大, 尽量远离 如果经营活动产生的现金流量净额在以往很好的情况下突然较大幅度下滑，应当引起投资者警惕，有可能是企业为了销售的增长而对下游放宽了信用政策，也有可能是企业加大了原材料的采购。信用政策放宽可以说明企业的行业地位可能在下降，但也有可能是企业为了抢占市场。 如果企业某一年购进商品、接受劳务支付的现金增长幅度大幅超过销售商品、提供劳务收到的现金，投资者应当留意，可能是以下几种情况 企业预计来年行业景气度提高，公司来年销售会大幅增加而提前做准备。 原材料价格大幅上升，这必将影响到企业的利润情况，因为成本增加了。 企业可能通过预付款这个科目将资金流出到虚构的上游，然后再将钱转移到虚构的下游，虚构的下游再购买公司的产品，由此达到虚增收入和利润的目的。 投资活动观金流(ICF) 投资活动现金流量是指企业长期资产(通常指一年以上)的购建及其处置产生的现金流量，包括购建固定资产、长期投资现金流量和处置长期资产现金流量，并按其性质分项列示。投资活动现金流量是指企业长期资产的购建和不包括现金等价物范围在内的投资及其处置活动产生的现金流量 投资活动流入，有两种情况 卖自己的家当，卖固定资产无形资产等， 卖对别人的投资和收到别人的投资分红或者利息。 收回投资收到的现金 处置固定资产、无形资产和其他长期资产收回的现金净额 处置子公司及其他营业单位收到的现金净额 收到其他与投资活动有关的现金 对于投资活动流出，两种情况 投钱给自己，表现为买固定资产、无形资产、其他长期资产； 投钱给别人，买别人的股票和债券，或组建子公司、合营公司 购建固定资产、无形资产和其他长期资产支付的现金 投资支付的现金 取得子公司及其他营业单位支付的现金净额(企业购买子公司及其他营业单位购买出价中以现金支付的部分，减去子公司及其他营业单位持有的现金和现金等价物后的净额。如果净额为负，应在“收到其他与投资活动有关的现金”中核算) 收到其他与投资活动有关的现金 投资活动现金流注意事项 投资活动产生的现金流量净额的正负可以判断企业当期的发展趋势是扩张还是收缩。若为负数，表明企业在扩张阶段，如为正，表明企业在收缩，或是扩张速度放缓 投资活动现金流入，若大部分来源于出售固定资产、无形资产、子公司等资产，可能是企业经营能力衰退业绩下滑，投资者需引起关注 取得投资收益收到的现金，体现的是当期实际收到的各类投资收益的现金。可与利润表中的投资收益对比，是账面浮盈还是真有实际收到 购建固定资产、无形资产和其他长期资产支付的现金，属于财务造假的高发区，通过虚增固定资产在建工程等将资金流出体外，投资者需重点关注 需关注所投项目是否在企业能力范围内。上下游和产业内的投资利于企业的长期发展，而什么都做的多元化可能就什么也不精，容易陷入多元化沼泽 筹资活动现金流(FCF) 指导致企业资本及债务的规模和构成发生变化的活动所产生的现金流量 现金流入 吸收投资收到的现金 向银行和其他金融机构借入的长期借款、短期借款 发行债券筹集的资金实际收到款项净额（发行收入减去支付的佣金等发行费用后的净额） 收到卖出回购金融资产的现金 现金流出 偿还债务支付的现金 分配股利、利润或偿付利息支付的现金 支付其它与筹资活动相关的现金 筹资活动现金流注意事项 根据企业筹资活动现金流入来源，可以判断企业的筹资来源的质量。比如吸收投资收到的现金是来源于IPO、定增还是配股；借款收到的现金是短期借款还是长期借款，借款利率是多少；发行债券是普通债券还是可转债，债券的利率是多少；其他项与筹资活动有关的来源都有哪些，占整个筹资来源的比例。 一般缺钱的公司筹资活动现金流净额很大，企业需要到处筹钱，想办法定增、配股，长短期借款，保理融资，票据贴现等，并且会想办法少分红甚至不分红，这样的公司就要小心了 优秀的企业往往筹资活动现金流入和流出项内容较少，收到其他与筹资活动有关的现金和支付其他与筹资活动有关的现金两项金额很小甚至没有，筹资活动现金流入金额很小，筹资活动现金流出主要以分配股利（分红）占大额，筹资活动现金流净额常常为负。 var className='atoc';"},"Finance/Accounting/财报被操纵的痕迹.html":{"url":"Finance/Accounting/财报被操纵的痕迹.html","title":"财报被操纵的痕迹","keywords":"","body":"财报被操纵的痕迹 利润表： 营业收入 高毛利产品销售收入大幅增加，公司正常产品销售结构扭曲，导致毛利率显著提升 销售以往没有生产或没有经销的产品营业收入 与某个以往财报中不存在的大客户进行大额交易，交易对该客户不具有合理用途，或者交易价格明显偏离正常价格 运费或装卸费增长比例显著低于销售收入增长比例 公司出口收入与海关费用之间变化趋势为反向变动 其他业务收入 其他业务收入和营业收入在营业收入中占比突然发生很大提升 公司利润主要来自偶然的营业外收入 销售费用和管理费用 销管费用占营业收入比例突然发生大幅降低，且显著低于竞争对手的水平营业外支出和一次性费用 营业外支出和一次性费用 财报出现金额较大的“其他\"，或者一些很少见过的科目名称 资产减值损失 资产减值损失同比大增，但按上年同期的资产减值损失水平测算，利润波动不 资产负债表上的固定资产、存货、应收账长款、金融资产大幅计提，及至价值归 现金流量表 经营活动现金流量净额 持续优于同行，投资活动现金净额持续为大额负数 持续多年为负 收到其他与经营活动有关的现金 应该偏小，突然增大，没有合理解释 筹资活动现金流中的的利息支出 借债利率比较高 高息借来债务，只是在银行存款或理财等明显低于借债利率的使用上 财报显示公司货币资金充足，又在高息借债 资产负偾表 应收账款 大幅增长，增幅超过同期收入增幅 收账款周专率低于同行水平，且呈明显下降趋势 其他应收款 这个科目大的公司，先把它当柞坏人 预付账款 大幅增加，尤其是预付工程款或预付专利或非专利技术的采购款大幅增加 预付账款挂账时间长，超过一年 应付账款和应付票据 科目数额增大说明 或者公司在商业遊条上的地位更加强势 或者公司资金链出问题拖欠供应商货款了 存货 数量和价值不易确定的存货大幅增长，旦增长幅度超过同期营业成本的增长 存货周转率低于同行水平，并呈下降趋势 存货周转率明显下降，却同时伴生着毛利率显著上升 在建工程 在建工程大幅增加，尤其是和生产经营规模和发展规划不相适应的大幅增加 在建工程迟迟不转固定资产 不断追加资金 刚转固定资产不久，又需要大修或技改 长期待摊费用 该科目大增，是不怡当使用费用资本化手段的信号 无形资产和商營 如专利或非专利采购数容交大，需要确认技术是否与公司生产经营紧密相关 如公司经常进行收购活动并产生大额商誉，有必要将商誉还原成资产，按照资产折旧规则，重新考虑公司价值 应付职工薪酬 应职工新酬余额波动大，递延所得税资产数额增加大，说明税务局不认可这坏账准备 坏账准备计提比例显著低于同行业竞争对手 坏账淮备 坏账准备计提比例显著低于同行业竟年对手 不考虑账龄因素、不公布账龄结构，统一按固定比例提取坏账准备1无法按时发布财报 财报以外的信号 无決按时发布财报 更换或再次更换会计师事务所 独立董事集体辞职 大股东持续减持 财务总监更换频繁 主要供应商或销售商可疑 var className='atoc';"},"Finance/Accounting/财报被操纵的手法.html":{"url":"Finance/Accounting/财报被操纵的手法.html","title":"财报被操纵的手法","keywords":"","body":"财报被操纵的手法 操纵收入 虚构收入 借助一次性行为夸大收入和提前确认 虚假交易、虚增成交金额、将非营利性交易确认为收入 显失公平的关联交易 借助一次性行为夸大收入 提前确认收入 确认尚未开始提供产品或服务的收入： 多期服务，直接将总金额确认在当年的营业收入里 年底签订合同，在合同约定义务尚未开始履行时，将合同款确认为当年收入 房地产公司以完工验收、收到房款确认收入等 买家没有明确承担付款义务时确认收入 向客户发送错误的货 向没有要求发货的客户发货 答应客户可以无条件退货的情况下，在退货期限内确认收入 向根本没有付款能力的客户大幅延长信用期的情况下发货 确认超过完工百分比对应的收入 对于使用完工百分比的公司（如建筑公司、装饰公司、系统集成公司、大型设备制造公司）改作假方法比较容易 销售并捆绑服务的公司，可以通过加大销售收入比例给销售，较小比例分配给后期维护，大幅增加营业收入 借助一次性行为夸大收入 将出售业务部门或资产所得转化为营业收入 将业务部门或资产低价出售 由买家将成交价与公允价格之间的差额，购买上市公司商品成服务 或者买家低价向上市公司提供产品或服务 目的：增加营业收入或降低营业成本 将上市公司的收购支出转为营业收入： 上市公司高价收购其他公司的业务部门或资产 卖家超过公允价格部分，用来采购上市公司产品或服务 或者卖家低价向上市公司提供商品成服务 目的：增加营业收入或降低营业成本 将亏损打包进一个子公司或部门，然后出售： 将上市公司日常经营亏损集中在一个子公司或部门 高价出售该子公司或者部门 上市公司通过借款、担保、项目合作、并购费用等补偿买家付出的高价 进行互换贸易夸大收入 高价出售商品或服务的同时，高价收购对方的商品或服务 操纵费用 将本期费用推至未来 延长折旧摊销年限 漠视已经形成损失的坏账 不适当地使用费用资本化手段 不对受损资产或过失存货提取减值准备 将费用暂时挂在应收账款或预付账款科目 推迟在建工程转为固定资产、甚至将日常费用计入在建工程 通过临时资金冲抵，将长时间坏账化妆成刚形成的应收款，降低坏账计提比例 掩盖成本或亏损 多计收入 少计原料成本 少计财务费用 少计销售、管理费用 洗大澡 利用财务技巧，有意将公司经营成资产情况恶化 方法 注销资产或存货，以减低未来折1日或增加末来盘盈 大额计提应收账款或存货差值损失，以便于未来转回 将经常性费用/归入一次性费用计提以减少未来费用 目的 为了把以前虚增的利润冲掉 为了未来报表好看 通常发生在公司被收购后或管理层更替时 在公司道遇经营困境时，把不好业绩做得更差 操纵现金流 增加经营活动现金流入 收购公司，让收购者应付款， 制造应收款， 从而获得收购公司的经营性现金流入 出售子公司或部门，作价的总款项分为首付款和未来收入分账，收入分账部分将计入经营活动现金流 出售子公司或部门，剥离并保留应收账款 先销售存货给出借方（银行或财务公司）到期再加价回购，创造本期经营活动现金流入 互换贸易，我买入你的设备，你买入我的产品。 你买我的产品，我帮你担保融资贷款 减少经营活动现金流出 某些经营活动现金支出归入投资活动或筹资活动 购买电影电视版权 租入网络带宽 以融资租赁代替租赁 以承兑汇票采购，减少当期经营活动现金流出。到期偿还时，记录为债务偿还，归入筹资活动现金流出 一次性行为美化经营活动现金净额 通过银行保理业务打折出售应收示，甚至伪造应收款出售并承担连带还款责任，夸大当期经营活动现金流入 给出高额折扣，刺激客户或在账期未到前付清应收款，或提供付款采购 拖欠供货商货款或减少正常采购，增加当期经营活动现金流量净额 var className='atoc';"},"Finance/Accounting/ROE-ROA-ROIC.html":{"url":"Finance/Accounting/ROE-ROA-ROIC.html","title":"ROE-ROA-ROIC","keywords":"","body":"ROE ROA ROIC的总结 概念 ROIC：投入资本回报率 = 息前税后利润 / 投入资本 ROE：权益回报率 = 净利润 / 股东权益 ROA：总资产回报率 = 净利润 / 总资产 我们这么看一个企业的资产负债表。企业经营资本来源于两个方面， 股本（股东给的钱）， 借钱（主要是银行给的钱）。 股本是要分红的，而借钱是要给利息的。企业取得这两块资金后，用于生产经营，这些钱各有去向： 资产：有的钱结余了（现金）；有的买了原材料（存货）；有的货卖了钱还没有收到（应收） 负债：有的买了原材料还没有付钱（应付账款）；员工上个月的工资还没发（应付工资） 不管怎资产负债表一边是资本（股本+借款）一边是投入（资产+负债） 两者永远是相等的 具体案例 假设公司股本1个亿，借款1个亿，资产3个亿，负债1个亿。到年底公司营收1个亿，利息400万（借款利率4%），净利润600万（销售净利率6%）。 不考虑所得税的问题，我们看看几个不同指标的计算结果： ROE = 600 / 10000 = 6% ROA = 600 / 30000 = 2% ROIC=（600 + 400）/ 20000 = 5% 如果公司把股本变成0.5亿，借款变成1.5亿，资产、负债不变。到年底，收入1个亿，利息600万（1.5亿x4%），净利润变成了400万（有200万付利息了）。 几个指标的结算结果如下： ROE=400 / 5000=8% ROA=400/30000=1.33% ROIC=（400+600）/ 20000=5% 结果是ROE提高了，ROA下降了，ROIC不变 有时ROA也有这么算的，（利润总额 + 利息支出）/总资产。 这种情况下，资本结构的变化确实不影响ROA了，但我们看看分母中总资产的构成是什么呢？ 包括股本、借款（有息）和负债（无息），分子是利润（对应股本）、利息（对应借款），负债没有对应项。 当一家公司不去增加银行贷款，而是减少应付账期时，它的ROA会得到提升。 这对于公司来讲是还是坏呢？看看阿里、京东这些电商平台，没有利息的负债，多一点会更好 这种情况下，ROA虽然不受【资本结构】的影响，但是受到【资产结构】的影响，所以也不利于公司间的比较。 因此看来看去，ROIC才是那个最有效的盈利指标 var className='atoc';"},"Finance/Accounting/复利.html":{"url":"Finance/Accounting/复利.html","title":"复利","keywords":"","body":"复利 什么是复利? 复利是指初始投资金额和投资几年所赚取的利息的应计利息，即利息的利息。例如，存款后，第一年的利息就按投资的初始金额计提。第二年，利息按初始存入的初始金额和上一年收到的利息累计。第三年，初始存款和先前收到的所有利息都计提利息。 在线计算器 在线复利计算器 在线年平均收益率计算器 复利公式 复利预期收益的计算可采用如下公式： A = P (1 + r/n)^t 各字母含义： A = 将在期末收到的金额， 终值 P = 初始投资额，即已投资的金额， 现值 r = 年利率， n = 应计利息期数（每月、每季度、每年等）， t = 总投资期（以年为单位）。 单利与复利的区别 这两种利息的主要区别在于所赚取的利息多少。采用单利时，利息主要根据存款的初始金额计提。不管计提第一年或第三年的利息金额，都没有任何差异——利息金额始终如一。 复利时，利息是在最初存款额加上前几年应计利息来赚取的。换句话说，加上前一年所赚取利息后增加的存款额作为当年利息的计算基础。简而言之，单利的基础总是相同，复利的基础，总是不同。 复利与单利的区别 单利 复利 期末一次计提利息 每年计提利息 计算时只考虑初始存款 计算时考虑到初始存款加上年收入 每年利润均一样 利润年年增加，即每年利息有所不同 如何反算年平均收益率 年平均收益率 还是使用原来的复利公式： A = P (1 + r/n)^t 已知终值A，现值P，求利率n， 转换一下公式： 假设 m为时间的倒数 m = \\frac {1} {t} 假设 y为终值和现值的收益比 y = \\frac {A} {P} 整理后计算的公式如下 n = log_{1 / t}^{A / P} - 1 举例： 假设一笔投资5年时间资产从100w到了300w，那么计算过程为： n = (log_3^5 - 1) * 100\\% = 24.57\\% 1年所获得的收益率 年化收益率 = (投资内收益 / 本金) ×（365/投资天数）× 100% 比如说花了10000元买入某只股票，90天后卖出，赚了502元。 取得的年化收益率是：(502 / 10000) ×（365 / 90）×100% = 20.36% 实际上，我们投资往往是分批，分期进行的，不止收益率不一样，投资的时间长度也不一样，所以我们要算的就是综合年化收益率。 var className='atoc';"},"Finance/Accounting/公司估值法.html":{"url":"Finance/Accounting/公司估值法.html","title":"公司估值法","keywords":"","body":"常见的公司估值方法 PE估值法 PE的内在含义 市盈率表示这家公司的净利润全部用于分红的情况下，收回总投资需要几年 例如：一家公司的市盈率是20，我们投资这家公司（净利润全部用来分红），需要20年收回成本 PE估值注意的问题 用PE是用历史数据看未来，具有一定的滞后性， 另外不同行业的PE没有可比性 扣非净利润更有意义 企业盈利不稳定，单一年份盈利很高的情况，导致单一年份的PE很低 PB估值法 PB（市净率，Price To Book Value） PB = 每股股价 / 每股净资产 = 总市值 / 总净资产 PS估值法 PS（市销率，Price To Sales）市销率表示公司获得一块钱收入，需要付出的价格, 市销率通常给那些具有成长性，但是'目前没有盈利'的公司估值 PEG估值法 自由现金流折现法 var className='atoc';"},"Finance/Accounting/重资产和轻资产.html":{"url":"Finance/Accounting/重资产和轻资产.html","title":"重资产和轻资产","keywords":"","body":"重资产和轻资产 轻资产企业与重资产企业 重资产公司 通常需要不断投入资金进行维护，更新或升级，并产生大量折旧，这在以通货膨胀为常态的时代，对股东并不友好 查理芒格曾经这样表述这种企业特征： 世界上有两种生意，第一种生意是你可以每年赚取12%的收益，然后年末你可以拿走所有的利润。第二种生意是你同样可以每年赚取12%的收益，但是你不得不把赚来的钱重新投资，然后你指着所有的厂房设备对股东们说，这就是你们的利润，我恨第二种生意 var className='atoc';"},"Finance/Industry/地产.html":{"url":"Finance/Industry/地产.html","title":"地产","keywords":"","body":"地产行业知识 概念 计容建筑面积 = 容积率 x 占地面积 楼面价 = 土地款 / 计容面积 货值 = 在售均价 x 计容面积 项目成本包括 土地成本 建安费用 销售费用 管理费用 相关税收等 土地成本 土地成本是指通过招拍挂旧改等方式取得土地所付成本 建安成本 项目建安成本是指完成项目主体建设所需要的资金包括开发前的评估规划费用, 咨询费用, 开发过程中的建筑主体建造费用, 装饰费用及工程工程费用等 在项目盈利估算时, 一般每平方建筑面积的建安费用乘以项目的总建筑面积计算 单位建筑面积建安费用取决于项目产品系列地区通货膨胀水平人工成本等影响差异较大。在具体的测算中要根据每个地区每个项目的不同进一步确认其成本 销售费用 销售费用是指项目在销售过程中产生的包括但不限于广告费、活动推广费、渠道费、销售人员佣金等。此类费用与各家房企的品牌溢价及所处区域有关，如果产品力得到认可，项目所处地段优越，其费用率将低于其他房企。这也是在房地产的白银时期，挑选标的的考量因素之一 管理费用 管理费用是指项目管理人员的工资、差旅费、福利等费用。实务中，大部分地产公司的销售与管理费用约占项目销售额的4-6% 财务费用 财务费用是指为项目建设所融资资金的费用，包括借款利息，发行手续费等。实务中，由于不同房地产项目采用的杠杆不同（融资比例不同）、融资成本不同，各家公司间的财务费用差异较大 var className='atoc';"}}